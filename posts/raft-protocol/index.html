<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=theme-color content="dark"><title>Raft 协议核心内容 | XX Blog</title><meta property="og:site_name" content="Hugo Tania is Amazing"><meta property="og:title" content="Raft 协议核心内容 | XX Blog"><meta itemprop=name content="Raft 协议核心内容 | XX Blog"><meta name=twitter:title content="Raft 协议核心内容 | XX Blog"><meta name=application-name content="Raft 协议核心内容 | XX Blog"><meta name=twitter:card content="summary"><meta name=description content="Raft 论文核心内容摘要"><meta name=twitter:description content="Raft 论文核心内容摘要 "><meta itemprop=description content=" Raft 论文核心内容摘要 "><meta property="og:description" content=" Raft 论文核心内容摘要 "><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=stylesheet href=/sass/main.min.ab99ff095f832511e24ffb2fba2b51ad473b2f7e9301d674eba2c6c3a6e8bd81.css></head><script>(function(){const e="ThemeColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="ThemeColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.userColorScheme="dark":document.documentElement.dataset.userColorScheme="light"})()</script><body class=dark><nav class=navbar><div class=container><div class=flex><div><a class=brand href=/><img src=/favicon.ico>
XX Blog</a></div><div class=flex><a href=/archives/>归档</a>
<a href=/posts/>文章</a>
<button id=dark-mode-button><svg class="light" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform:rotate(360deg);-webkit-transform:rotate(360deg);transform:rotate(360deg)" viewBox="0 0 36 36"><path fill="#ffd983" d="M30.312.776C32 19 20 32 .776 30.312c8.199 7.717 21.091 7.588 29.107-.429C37.9 21.867 38.03 8.975 30.312.776z"/><path d="M30.705 15.915a1.163 1.163.0 101.643 1.641 1.163 1.163.0 00-1.643-1.641zm-16.022 14.38a1.74 1.74.0 000 2.465 1.742 1.742.0 100-2.465zm13.968-2.147a2.904 2.904.0 01-4.108.0 2.902 2.902.0 010-4.107 2.902 2.902.0 014.108.0 2.902 2.902.0 010 4.107z" fill="#ffcc4d"/><rect x="0" y="0" width="36" height="36" fill="rgba(0, 0, 0, 0)"/></svg><svg class="dark" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform:rotate(360deg);-webkit-transform:rotate(360deg);transform:rotate(360deg)" viewBox="0 0 36 36"><path fill="#ffd983" d="M16 2s0-2 2-2 2 2 2 2v2s0 2-2 2-2-2-2-2V2zm18 14s2 0 2 2-2 2-2 2h-2s-2 0-2-2 2-2 2-2h2zM4 16s2 0 2 2-2 2-2 2H2s-2 0-2-2 2-2 2-2h2zm5.121-8.707s1.414 1.414.0 2.828-2.828.0-2.828.0L4.878 8.708s-1.414-1.414.0-2.829c1.415-1.414 2.829.0 2.829.0l1.414 1.414zm21 21s1.414 1.414.0 2.828-2.828.0-2.828.0l-1.414-1.414s-1.414-1.414.0-2.828 2.828.0 2.828.0l1.414 1.414zm-.413-18.172s-1.414 1.414-2.828.0.0-2.828.0-2.828l1.414-1.414s1.414-1.414 2.828.0.0 2.828.0 2.828l-1.414 1.414zm-21 21s-1.414 1.414-2.828.0.0-2.828.0-2.828l1.414-1.414s1.414-1.414 2.828.0.0 2.828.0 2.828l-1.414 1.414zM16 32s0-2 2-2 2 2 2 2v2s0 2-2 2-2-2-2-2v-2z"/><circle fill="#ffd983" cx="18" cy="18" r="10"/><rect x="0" y="0" width="36" height="36" fill="rgba(0, 0, 0, 0)"/></svg></button></div></div></div></nav><main><div class=container><article><header class=article-header><div class=thumb><div><h1>Raft 协议核心内容</h1><div class=post-meta><div>By Hugo Tania | <time>March 01, 2023</time>
| 3 minutes</div><div class=tags><a href=/tags/%E9%98%85%E8%AF%BB/>阅读</a></div></div></div></div></header></article><div class=article-post><h2 id=关于-raft><a href=#%e5%85%b3%e4%ba%8e-raft class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>关于 raft</h2><p>Raft<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> 是一种共识算法，它能够使得系统成员部分失效后，系统仍然能够工作。本质上是一个备份状态机，它具有以下特性：</p><ul><li>安全性：永远不会返回错误数据（尽管存在拜占庭故障、网络分区、延迟、丢包等）</li><li>高可用：只要大多数节点存活（互相之间能通讯，能被客户端访问到），系统就是可用的</li><li>共识日志不依赖时间（因为系统可能存在时间故障、严重延迟等）</li><li>一般情况下，只要集群大多数响应命令完成，则此命令就会完成，避免少量慢节点影响整体服务性能</li></ul><p>Raft 部分思想受 Paxos、zab 等协议启发，但 Raft 协议简单很多：作者在论文中多次强调 Paxos 过于复杂，他们花了一年时间才真正搞懂 Paxos 究竟是如何工作的。而 Raft 协议的初衷就是创建一个更简单的共识算法，更简单意味着可以被更多人学习、理解，能更好的在生产中实现、使用。</p><p><a href=http://thesecretlivesofdata.com/raft/>这个网站</a><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>使用分步动画形式很好的解释了 raft 的运行方式，通过它可以对 raft 协议有大致的认识。</p><h2 id=raft-共识算法概要><a href=#raft-%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95%e6%a6%82%e8%a6%81 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Raft 共识算法概要</h2><p>Raft 算法要求先选出 leader，然后 leader 接收客户端的 log entries，复制给其他 servers，并告诉它们什么时候可以把 log entries 应用到它们的状态机。</p><p>Raft 协议把共识算法分解成三个互相无依赖的子问题：</p><ul><li>Leader election：当现有的 leader 失效后，必须选举出新 leader</li><li>Log replication：leader 从客户端接收 log entries，并复制到集群的其他 servers 上</li><li>Safety：如果一个 server 把某个 log entry 应用到它的状态机，则集群其他 server 与此 log entry 相同的 log index 上，使用的都是同一个 log entry.</li></ul><h2 id=raft-详细内容><a href=#raft-%e8%af%a6%e7%bb%86%e5%86%85%e5%ae%b9 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Raft 详细内容</h2><h3 id=所有服务器的持久状态persistent-state><a href=#%e6%89%80%e6%9c%89%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%9a%84%e6%8c%81%e4%b9%85%e7%8a%b6%e6%80%81persistent-state class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>所有服务器的持久状态（persistent state）：</h3><ul><li>currentTerm: 服务器上次看到的 term</li><li>votedFor: 当前 term 收到投票的服务器ID，如果没有，是 null</li><li>log[]: log entries，从 leader 接收到的每个 entry 都包含状态机的命令，和当时的 term</li></ul><h3 id=所有服务器的不稳定状态-volatile-state><a href=#%e6%89%80%e6%9c%89%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%9a%84%e4%b8%8d%e7%a8%b3%e5%ae%9a%e7%8a%b6%e6%80%81-volatile-state class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>所有服务器的不稳定状态 （volatile state）：</h3><ul><li>commitIndex: 已知需要提交的最高 log 的 index</li><li>lastApplied: 已经应用到状态机的最高 log 的 index</li></ul><h3 id=leader-服务器的不稳定状态选举后重新初始化><a href=#leader-%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%9a%84%e4%b8%8d%e7%a8%b3%e5%ae%9a%e7%8a%b6%e6%80%81%e9%80%89%e4%b8%be%e5%90%8e%e9%87%8d%e6%96%b0%e5%88%9d%e5%a7%8b%e5%8c%96 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>leader 服务器的不稳定状态（选举后重新初始化）</h3><ul><li>nextIndex[] 需要发送给特定 server 的下一个 entry 的 index（初始化为 leader last log index + 1）</li><li>matchIndex[] 已知在每个 server 上已复制的 index</li></ul><h3 id=appendentries-rpc><a href=#appendentries-rpc class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>AppendEntries Rpc</h3><p>leader 调用用来备份 entries；同时也是用来作为心跳的 rpc
参数：</p><ul><li>term: leader 的 term</li><li>leaderId: follower 可以据此重定向 client 的请求</li><li>entries[]: 同步的命令，可以为空</li><li>prevLogIndex: entries 前一个 entry 的索引</li><li>prevLogTerm: prevLogIndex 的 term</li><li>leaderCommit leader 的提交索引</li></ul><p>响应：</p><ul><li>term：接收端 currentTerm，leader 可以根据响应更新自己的状态。（比如 leader 落后 term，变为 follower）</li><li>success: 如果 follower 包含对应的 prevLogIndex 和 prevLogTerm，则是 true</li></ul><p>接收端实现：</p><ol><li>如果 term &lt; currentTerm，return false</li><li>如果 prevLogIndex， prevLogTerm 不存在，则 return false</li><li>如果已存在的 entry 与 new entries 冲突（相同 index，不同 term），删除现有的 entry，使用 leader 的 entries</li><li>新的 entries 全部 append 到 log 中</li><li>如果 leaderCommit > commitIndex, 把 commitIndex 设置为 min(leaderCommit, index of last new entry)</li></ol><h3 id=requestvote-rpc><a href=#requestvote-rpc class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>RequestVote Rpc</h3><p>候选人调用，获取选票。</p><p>参数：</p><ul><li>term: 候选人的 term</li><li>candidateId: 候选人id</li><li>lastLogIndex: 候选人最后一条 log entry 的 index</li><li>lastLogTerm: 候选人最后一条 log entry 的 term</li></ul><p>响应：</p><ul><li>term: currentTerm，候选人根据此 term 更新自己</li><li>voteGanted: 为 true 表示候选人得到了选票</li></ul><p>接收端实现：</p><ol><li>如果 term &lt; currentTerm，则 return false</li><li>如果 votedFor 是 null 或者 candidateId，且候选人日志至少是最新的（比投票人的 lastLogIndex 更新或相同），投票为 true</li></ol><h3 id=servers-的规则><a href=#servers-%e7%9a%84%e8%a7%84%e5%88%99 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>Servers 的规则</h3><p>All Servers:</p><ul><li>如果 commitIndex > lastApplied，增加 lastApplied，并把 <code>log[lastApplied]</code> 应用到状态机</li><li>如果 RPC 请求或响应存在 term T > currentTerm，设置 currentTerm = T，并设置为 follower</li></ul><p>Followers:</p><ul><li>响应 candidate 和 leader 的 rpc 调用</li><li>如果选举超时结束，且没有收到 leader 的 AppendEntries RPC 和 candidate 的 RequestVote RPC，则变为 candidate</li></ul><p>Candidate:</p><ul><li>当变为 candidate 后，开始选举<ul><li>增加 currentTerm</li><li>投票给自己</li><li>重设 election timer</li><li>向其他 server 发送 RequestVoteRpc</li></ul></li><li>如果收到大多数 server 的选票，变为 leader</li><li>如果收到新 leader 的 AppendEntries RPC，则变为 follower</li><li>election timer 超时，重新开启选举</li></ul><p>Leader:</p><ul><li>选举时，发送空 AppendEntriesRPC 到每个 server；空闲期间重复发送，避免选举超时</li><li>收到 client 的命令后：把 entry 追加到本地 log，当 entry 被应用状态机后返回</li><li>如果 follower 的 last log index >= nextIndex，AppendEntryRpc 的 entries 从 nextIndex 开始发送<ul><li>如果 success，更新记录 follower 的 nextIndex 和 matchIndex</li><li>如果 fail，减小 nextIndex，并重试</li></ul></li><li>如果存在 N， N > commitIndex，且大多数的 matchIndex[i] >= N, 且 log[N].term == currentTerm，set commitIndex = N</li></ul><h3 id=安全性保证><a href=#%e5%ae%89%e5%85%a8%e6%80%a7%e4%bf%9d%e8%af%81 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>安全性保证</h3><p>通过以上逻辑，Raft 可以实现下面的安全性保证。</p><p>选举安全：每个 term 只能有一个 leader 被选举出来。</p><p>Leader 日志仅追加（Append-Only）: leader 不会修改或删除它的本地 Log，仅追加。</p><p>日志匹配（Log Matching）: 如果两个 logs 有相同的 index 和 term，则这两个 logs 里所有的 entry 都是相同的。</p><p>Leader 完备（Leader Completeness）: 如果在特定 term 提交了一个 entry，则在所有更高 term 的 leader 里，它都是存在的。</p><p>状态机安全：如果一个 server 已经 apply a entry 到状态机，则相同的 index 下，其他 server apply 的是同一个 entry。</p><p>Leader 只会通过计数本任期 term 下产生的 entry 的备份数量，来提交 entry（设置 commitIndex）。</p><h2 id=其他><a href=#%e5%85%b6%e4%bb%96 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>其他</h2><p>时间与可用性：广播时间 &#171; 选举超时时间 &#171; 崩溃间隔。内网广播时间（请求响应一来一回的时间）通常是几毫秒内；崩溃间隔通常几天、几月甚至更长。选举超时时间一般随机设置在 150ms - 300ms，太长会影响 leader 崩溃后系统的恢复速度，太短则可能频发引发选举。</p><p>集群成员改变（增减）：使用 config log entry 同步成员信息，保证配置信息共识。成员初次加入需要同步数据，同步数据时没有投票权，不占大多数计算逻辑；直到追上日志后才能投票。</p><p>日志压缩：快照模式，各个 server 管理自己的快照。快照后，前面的 log entries 可以删除。如果 leader 给 follower 需要同步的日志已删除，需要接口先同步快照，再同步后面的日志。同步快照使用 InstallSnapshot RPC。</p><p>客户端交互：客户端随机选择节点发起请求，如果是 follower 节点，则节点拒绝请求，并返回 leader 信息。客户端向 leader 发起请求。</p><p>为了避免 <strong>leader 已提交但未响应 client 后崩溃，client 重新请求新 leader 节点会导致命令多次执行</strong>，每个 command 需要带一个唯一标识，新 leader 包含所有已提交 entry，遇到相同的唯一标识的 command，直接返回已执行即可。</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://raft.github.io/raft.pdf>Diego Ongaro and John Ousterhout Stanford University</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=http://thesecretlivesofdata.com/raft/>Raft: Understandable Distributed Consensus</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></div><div class=container><nav class="flex container suggested"><a rel=prev href=/posts/read-ddia/ title="Previous post (older)"><span>Previous</span>
读《设计数据密集型应用》</a>
<a rel=next href=/posts/go-runtime-explore/ title="Next post (newer)"><span>Next</span>
Golang 运行时探究</a></nav></div><div class=container><script src=https://giscus.app/client.js data-repo=xiang-xx/xiang-xx.github.io data-repo-id=R_kgDOI4YfdA data-category=Comment data-category-id=DIC_kwDOI4YfdM4CT7aL data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-theme=light crossorigin=anonymous async></script><script>function setGiscusTeheme(e){let t=document.querySelector(".giscus iframe");t&&t.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}addEventListener("message",e=>{if(e.origin!=="https://giscus.app")return;setGiscusTeheme(document.documentElement.dataset.userColorScheme)}),window.addEventListener("onColorSchemeChange",e=>{setGiscusTeheme(e.detail)})</script></div></main></main><footer class="footer flex"><section class=container><nav class=footer-links><a href=/index.xml>RSS</a></nav></section><script defer src=/ts/features.706a523ba43e6d0427c7fdf2b9d05dbd0920d3f12942b453690b495cb2522743.js data-enable-footnotes=true></script></footer></body></html>
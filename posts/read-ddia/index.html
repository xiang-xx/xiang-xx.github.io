<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=theme-color content="dark"><title>读《设计数据密集型应用》 | XX Blog</title><meta property="og:site_name" content="Hugo Tania is Amazing"><meta property="og:title" content="读《设计数据密集型应用》 | XX Blog"><meta itemprop=name content="读《设计数据密集型应用》 | XX Blog"><meta name=twitter:title content="读《设计数据密集型应用》 | XX Blog"><meta name=application-name content="读《设计数据密集型应用》 | XX Blog"><meta name=twitter:card content="summary"><meta name=description content="数据密集型应用设计的核心理念"><meta name=twitter:description content="数据密集型应用设计的核心理念 "><meta itemprop=description content=" 数据密集型应用设计的核心理念 "><meta property="og:description" content=" 数据密集型应用设计的核心理念 "><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=stylesheet href=/sass/main.min.ab99ff095f832511e24ffb2fba2b51ad473b2f7e9301d674eba2c6c3a6e8bd81.css></head><script>(function(){const e="ThemeColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="ThemeColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.userColorScheme="dark":document.documentElement.dataset.userColorScheme="light"})()</script><body class=dark><nav class=navbar><div class=container><div class=flex><div><a class=brand href=/><img src=/favicon.ico>
XX Blog</a></div><div class=flex><a href=/archives/>归档</a>
<a href=/posts/>文章</a>
<button id=dark-mode-button><svg class="light" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform:rotate(360deg);-webkit-transform:rotate(360deg);transform:rotate(360deg)" viewBox="0 0 36 36"><path fill="#ffd983" d="M30.312.776C32 19 20 32 .776 30.312c8.199 7.717 21.091 7.588 29.107-.429C37.9 21.867 38.03 8.975 30.312.776z"/><path d="M30.705 15.915a1.163 1.163.0 101.643 1.641 1.163 1.163.0 00-1.643-1.641zm-16.022 14.38a1.74 1.74.0 000 2.465 1.742 1.742.0 100-2.465zm13.968-2.147a2.904 2.904.0 01-4.108.0 2.902 2.902.0 010-4.107 2.902 2.902.0 014.108.0 2.902 2.902.0 010 4.107z" fill="#ffcc4d"/><rect x="0" y="0" width="36" height="36" fill="rgba(0, 0, 0, 0)"/></svg><svg class="dark" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform:rotate(360deg);-webkit-transform:rotate(360deg);transform:rotate(360deg)" viewBox="0 0 36 36"><path fill="#ffd983" d="M16 2s0-2 2-2 2 2 2 2v2s0 2-2 2-2-2-2-2V2zm18 14s2 0 2 2-2 2-2 2h-2s-2 0-2-2 2-2 2-2h2zM4 16s2 0 2 2-2 2-2 2H2s-2 0-2-2 2-2 2-2h2zm5.121-8.707s1.414 1.414.0 2.828-2.828.0-2.828.0L4.878 8.708s-1.414-1.414.0-2.829c1.415-1.414 2.829.0 2.829.0l1.414 1.414zm21 21s1.414 1.414.0 2.828-2.828.0-2.828.0l-1.414-1.414s-1.414-1.414.0-2.828 2.828.0 2.828.0l1.414 1.414zm-.413-18.172s-1.414 1.414-2.828.0.0-2.828.0-2.828l1.414-1.414s1.414-1.414 2.828.0.0 2.828.0 2.828l-1.414 1.414zm-21 21s-1.414 1.414-2.828.0.0-2.828.0-2.828l1.414-1.414s1.414-1.414 2.828.0.0 2.828.0 2.828l-1.414 1.414zM16 32s0-2 2-2 2 2 2 2v2s0 2-2 2-2-2-2-2v-2z"/><circle fill="#ffd983" cx="18" cy="18" r="10"/><rect x="0" y="0" width="36" height="36" fill="rgba(0, 0, 0, 0)"/></svg></button></div></div></div></nav><main><div class=container><article><header class=article-header><div class=thumb><div><h1>读《设计数据密集型应用》</h1><div class=post-meta><div>By Hugo Tania | <time>February 25, 2023</time>
| 3 minutes</div><div class=tags><a href=/tags/%E9%98%85%E8%AF%BB/>阅读</a></div></div></div></div></header></article><div class=article-post><h2 id=前言><a href=#%e5%89%8d%e8%a8%80 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>前言</h2><p>互联网企业里或多或少都会有些数据密集型系统，比如一家互联网教育企业，付费用户虽然不多，但视频观看打点频率高，观看日志的数据量可以很大；一个在线聊天软件，用户聊天数据也会快速增长。《设计数据密集型应用》<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>一书内容丰富，涵盖了数据系统存储细节、分布式、数据一致性等问题，由浅入深，由底层细节到顶层架构，循序渐进地展开一张数据密集型系统的画卷全貌。</p><h2 id=可靠性可伸缩性和可维护性><a href=#%e5%8f%af%e9%9d%a0%e6%80%a7%e5%8f%af%e4%bc%b8%e7%bc%a9%e6%80%a7%e5%92%8c%e5%8f%af%e7%bb%b4%e6%8a%a4%e6%80%a7 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>可靠性、可伸缩性和可维护性</h2><p>与数据密集型系统对应的是计算密集型系统。在互联网行业中，更常见的是数据密集型系统。此书的目标是介绍如何打造<strong>可靠、可伸缩、可维护</strong>的数据系统。</p><ul><li>可靠性：系统在困境中（硬件故障、软件故障、人为错误）仍可以正常工作</li><li>可伸缩性：有合理的办法应对系统的增长（数据量，流量，复杂性）</li><li>可维护性：许多不同的人，在不同的声明周期，都能高效的在系统上工作</li></ul><p>提高可靠性：</p><ul><li>硬件：提高冗余度</li><li>软件：彻底的测试、进程隔离、允许崩溃重启、测量/监控/自检/报警等</li><li>人为错误：沙箱环境、只读环境、允许快速回滚、允许数据重算、API 限制、管理后台、人员培训等（最小化犯错误机制，允许犯错并修复，监控错误产生）</li></ul><p>性能：批处理关注吞吐量，在线服务系统关注<strong>响应时间</strong>。</p><p>通常使用响应时间的高位百分比描述服务性能。比如: 50%的响应小于200ms，99% 的响应时间小于 1s，即 <code>p50&lt;100ms, p99&lt;1s</code>。</p><p>可伸缩性：纵向伸缩（scaling up），横向伸缩（scaling out）。</p><p>可维护性与软件系统设计的原则：</p><ul><li>可操作性：便于（运维团队）维护系统平稳运行</li><li>简单性：从系统中尽可能消除复杂度。减少系统状态、降低模块耦合、理清依赖关系、术语命名一致&mldr;</li><li>可演化性（可扩展性，可塑性）</li></ul><h2 id=数据模型与查询语言><a href=#%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b%e4%b8%8e%e6%9f%a5%e8%af%a2%e8%af%ad%e8%a8%80 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>数据模型与查询语言</h2><p>常见的数据模型：</p><ul><li>网状模型（CODASQL 为例）：数据库存在模式；访问特定记录需要遍历其中一条路径；查询是命令式，难以编写和维护</li><li><strong>关系型：写时模式（schema-on-write）</strong>；范式设计导致从数据到代码对象需要复杂的转化；能够更好的处理多对多的关系；查询时通常需要遍历更多的数据</li><li><strong>文档型：读时模式（schema-on-read）</strong>；代码查询简单；文档引用技术解决多对多的关系；查询局部性相对好；更新文档通常需要整个重写。</li><li><strong>图模型</strong>：更适合多对多的关系；顶点和边不仅限于一种类型，顶点可以表示人、地点、事件，边可以表示哪些人彼此是好友、谁参与了哪个事件；适用于社交图谱，网络图谱，公路铁路网络等。</li><li>其他：用于基因相似性检测的搜索引擎（序列相似性搜索）；全文搜索；PB级大数据存储模型。</li></ul><p>声明式查询语言（SQL，mongo，es）：简单容易；隐藏了数据库细节，便于兼容前后版本；适合并行查询。</p><p>命令式查询语言（例如 CODASQL）：类似编程语言的执行逻辑。</p><p>MapReduce 介于声明式和命令式之间，使用代码逻辑编写，但能够并行在多台机器上分布式执行。</p><h2 id=存储与检索><a href=#%e5%ad%98%e5%82%a8%e4%b8%8e%e6%a3%80%e7%b4%a2 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>存储与检索</h2><p>存储引擎的两个大类</p><ul><li>日志结构（log-structured）</li><li>面向页面（page-oriented）</li></ul><p>日志结构存储引擎通常是<strong>追加写</strong>，在机械硬盘上性能较好，崩溃恢复简单，日志文件分段，删除使用特殊的标记，段文件可以后台合并，单独一个写线程避免并发问题。</p><p>日志结构的散列索引：范围查询性能很低；必须能够放在内存里，否则磁盘映射性能很低。</p><p>SSTable 排序字符串表，<strong>LSM（日志文件合并树）</strong>：</p><ul><li>每个段文件内 key 是有序的</li><li>多个段文件合并后按照 key 的顺序写入到新段文件</li><li>当前段文件使用有序结构（红黑树等）维护在内存中，磁盘维护当前分段的顺序写日志；达到一定阈值，写入新段文件，删除旧的顺序写日志</li><li>使用 bloom 过滤器，优化不存在的 key 的查找</li><li>有序 key 可以加快范围查询</li></ul><p>面向页面结构的存储引擎通常使用 <strong>B 树</strong>及其变体作为存储引擎。
<img loading=lazy src=/./img/btree.png alt=btree width=1140 height=658></p><ul><li>B 树将数据库分解成固定大小的块或页，一次性只能读取或写入一个页面；这种设计接近底层页面，因为磁盘空间也是按照固定大小组织的</li><li>页面之间使用地址（硬盘地址，而非内存地址）互相引用，构建出树</li><li>一个页面的引用数量称为<strong>分支因子</strong>，通常是几百（分支因子为 500 的 4KB 页面的四层树可以存储 256T 数据）</li><li>使用预写日志（WAL，或重做日志 redo log，追加写文件）实现崩溃恢复</li><li>使用锁控制页面写入</li><li>如果一个页满了，则分裂成两个半页</li></ul><p><strong>B 树相关优化</strong>：</p><ul><li>字符串 key 可以不存储整个键，缩短键大小以增大分支因子</li><li>写时复制，经过修改的页面写入到不同位置，便于并发控制和崩溃恢复</li><li>使叶子页面尽量放在相同的位置</li><li>额外的指针，使用每个叶子页面可以连接左右兄弟页面，顺序扫描不需要跳回父级</li><li>分形树（fractal tree）<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>，在节点上缓存变更操作，接用日志结构的思想减少磁盘查找</li></ul><p>数据仓库的<strong>列式存储</strong>（在线分析处理 OLAP）：</p><ul><li>每个列存储在单独的文件，所有列包含的行的顺序是对应的，可以通过列构建出行</li><li>数仓事实表的列通常很多，数据分析时只关心若干列，没必要把其他列读出来</li><li>列数据存储在一起便于压缩，比如有些列只有若干可能的值，通过位图编码可以极大压缩；列排序后对于压缩更友好</li><li>使用 LSM，分批次写入数据，降低大量数据写入的瓶颈</li><li>物化视图，对于 count、sum、svg、max 等数据物化存储，便于查询</li></ul><h2 id=编码和演化><a href=#%e7%bc%96%e7%a0%81%e5%92%8c%e6%bc%94%e5%8c%96 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>编码和演化</h2><p>常用的文本格式编码：json，xml，csv；易读，但数据量相对大；二进制编码：protobuf，thrift；数据量通常能压缩 20% 以上，缺点是不可读；编程语言特定的编码仅限于单一语言，通常不使用。</p><h2 id=复制><a href=#%e5%a4%8d%e5%88%b6 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>复制</h2><p><strong>主从模式</strong>是比较常见的模式模式。Mysql、redis、PostgreSQL、kafka 等都是用主从模式。</p><p>同步复制：主库等待从库复制完成再响应请求。能够保证从库与主库数据一致，主库不可用时，从库包含完整的数据。但如果从库故障，主库也无法写入。</p><p>半同步：一个从库使用同步复制，其他从库是异步的。确保有一个从库是同步复制的。</p><p>异步复制：主库的写入不能保证持久。</p><p><strong>复制的实现</strong>：</p><ul><li>基于语句的复制：使用非确定性的语句、函数，以及现有数据不一致时，可能导致语句在从库上产生的效果不同。</li><li>基于预写日志复制（WAL）：预写日志通常涉及到底层存储，比如覆写某个磁盘页，不同版本之间可能不兼容。</li><li><strong>基于行的逻辑日志复制</strong>（例如 binlog）：将复制日志从存储引擎中解耦出来，且对于外部来说，逻辑日志更容易解析，便于发送到外部系统中处理</li><li>基于触发器的复制：灵活性强，但开销比较高。</li></ul><p>异步复制因为网络延迟的存在，只提供最终一致性。</p><p><strong>读己之写</strong>：用户提交完数据想要立刻查看，则新数据未到达副本，可能导致未查到，像是数据丢失。确保写后读一致性的一些方式：</p><ul><li>对于用户可能修改过的数据，总是从主库读。比如用户读取自己的个人信息走主库，读取其他人的信息走从库</li><li>如果应用的大部分内容都可能被用户编辑，则可以跟踪上次更新时间来决定是否读从库。还可以监控从库延迟</li><li>客户端可以记录最后一次写入的 逻辑时间戳，据此判断是否读从库</li><li>如果副本分布在不同地理位置的数据中心，则更复杂。任何需要主库提供服务的请求，都需要被路由到主库所在的数据中心</li></ul><p><strong>单调读</strong>：确保每个用户总是从一个副本读取，避免来回切换延迟时间不同的副本，导致读的数据一会儿有一会儿没有。</p><p><strong>一致前缀读</strong>：具有因果关系的一系列数据写入后，读取这些数据也必须按照相同的顺序出现。比如 A，B 两个有因果关系的事件先后写入数据库后，用户读从库的时候不能只读到 B 但没有读到 A。通常在分片或分区数据库中会出现这种场景，需要确保具有因果关系的事件写入到相同分区。</p><p><strong>多主复制</strong>的使用场景：</p><ul><li>运维多个数据中心，数据就近访问，降低地理位置导致的延迟</li><li>需要离线处理的客户端，比如印象笔记</li><li>协同编辑</li></ul><p>多主复制最大的问题是写入冲突。</p><ul><li>避免冲突：对相同记录的操作路由到同一个数据中心</li><li>收敛至一致的状态：每个写分配一个 ID，冲突时 ID 大的覆盖小的（数据丢失）；以某种方式把值合并在一起；编写解决冲突的代码。</li></ul><p>多主复制的一些拓扑：
<img loading=lazy src=/./img/mmcopy.png alt=mmcopy width=1120 height=336></p><p><strong>无主复制</strong>：客户端直接将写入发送到多个副本（通常会有个协调者节点，代替客户端写入，节点之间没有固定写入顺序）。无主复制处理节点数据不一致方案：</p><ul><li>读修复：读取时，修复陈旧的节点数据（冷数据可能用于读不到，不会修复）</li><li>反熵过程：后台进程不断查找副本差异，修复数据</li></ul><p><strong>读写的法定人数</strong>：假设有 n 和副本，w 个副本确认表示写入成功，读取时需要从 r 个副本读取</p><ul><li>需要确保 w+r > n，这样读的副本里至少有一个是最新的</li><li>通常 w = r = (n+1)/2</li><li>w 越大，r 越小；则 读取效率高，写入效率低，适合读多写少的系统；</li></ul><p><strong>检测并发写入</strong>：多个客户端可以同时对一个 key 写入，但写操作可能按照不同顺序到达不同节点。并发写入规避方案：</p><ul><li>LWW 最后写入胜利：每个请求加一个时间戳，大的覆盖小的</li><li>一个键只允许写入一次，不允许更新</li><li>写入前先读取，读取值包含版本号，写入时传入版本号，只能覆盖相同或更低的版本号</li><li>使用客户端程序合并写入</li><li>版本向量：对于一个键值，所有副本的版本号的集合成为版本向量，读取值时，版本向量会发送给客户端，写入时需要传给数据库。版本向量允许数据库区分覆盖写入和并发写入。</li></ul><h2 id=分区><a href=#%e5%88%86%e5%8c%ba class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>分区</h2><p>分区通常和复制同时使用，每个分区的副本存储在多个节点上。如果分区是不公平的，则一些分区比其他分区有更多的数据和查询，产生<strong>数据偏斜</strong>，导致分区效率下降。</p><p>根据键的<strong>范围分区</strong>。例如百科全书按照关键字的分区。分区边界可以由管理员手动选择，也可以由数据库自动选择。Bigtable/HBase 使用类似方法。优点是存在顺序性，便于范围查找；但容易造成数据倾斜。比如键中带有时间戳 &ndash; 可以在时间戳前面加上其他的字段。</p><p>根据键的<strong>散列分区</strong>。好的散列函数可以把键均匀分布，但范围查询效率低。</p><p>Cassandra 的折衷策略：主键采用多个列组成，第一个列用作 hash 分区，后续键使用 SSTables 排序；如果指定了第一个键查询，则后续的键可以范围查找。</p><p><strong>负载偏斜与热点消除</strong>：极端情况下，某些键会被大量的读取写入，比如热点微博的数据；这种热点数据或造成分区的负载偏斜。解决方案：使用一定策略，判断这些键需要被额外分区，比如后面加上后缀，{id}_0,{id}_1&mldr; 把热点数据分成若干份，存储在不同分区，读取的时候再进行合并。</p><p><strong>基于文档的次级索引进行分区</strong>。即每个分区维护自己分区内文档的次级索引，查询的时候并发从各个分区查询；这种方案比较简单，但并发多条查询容易导致尾部延迟放大。</p><p><strong>基于关键词（term）的次级索引进行分区</strong>。构建覆盖所有分区数据的全局索引，全局索引也需要分区，可以采用与主键不同的分区方式。 关键词分区；关键词（term）源自全文搜索引擎，指文档中出现的所有单词。这种次级索引分区方式写入速度慢，且比较复杂；在实践中，对全局索引的更新通常是异步的。</p><p>分区<strong>再平衡</strong>策略：</p><ul><li>反面教材：hash mod n，导致再平衡发生时大量数需要移动</li><li><strong>固定数量的分区</strong>：分区数量比节点数量多，比如 5个节点，100 个分区，如果一个节点挂了，则另外四个节点均分挂掉的 20 个分区。 Riak/ES/CouchBase/Voldemort 都使用这种策略</li><li>动态分区：分区增长到一定大小时，会被分成两个分区，各拥有一半数据；如果大量数据删除，分区变小，则可以合并分区。动态分区同时支持 hash 分区和范围分区。 HBase/MongoDB</li><li>按节点比例分区：分区数与节点数成正比，即每个节点具有固定数量的分区，通常每个节点的分区数比较多，以保证数据的平衡。Cassandra 中，每个节点默认 256 个分区。</li></ul><p>分区<strong>请求路由</strong>方式：</p><ul><li>允许客户连接任何节点（通过循环策略的负载均衡，Round-Robin Load Balancer），如果节点有请求的分区，则直接处理请求；否则，它转发到其他节点，收到回复并返回给客户端</li><li>将客户的请求发送到路由层，它决定应该处理请求的节点，并进行转发</li><li>要求客户端知道分区和节点的分配</li></ul><h2 id=事务><a href=#%e4%ba%8b%e5%8a%a1 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>事务</h2><p><strong>事务的 ACID</strong>：</p><ul><li>原子性（Atomicity）：能够在错误时中止事务，丢弃该事务的所有写入变更的能力</li><li>一致性（Consistency）：对数据的一组特定约束始终不变</li><li>隔离性（Isolation）：同时执行的事务是相互隔离的。</li><li>持久性（Durability）：持久性是一个承诺，即一旦事务完成，即使发生硬件故障或数据库崩溃，写入的任何数据也不会丢失。完美的持久性是不存在的。</li></ul><p><strong>非事务的 BASE</strong>：</p><ul><li>基本可用性（Basically Available）</li><li>软状态（Soft State）</li><li>最终一致性（Eventual Consistency）</li></ul><p>对于应用而言，没有事务，错误处理复杂很多；没有隔离性，就会导致并发问题。</p><p>可串行化的隔离级别保证事务的执行效果如同串行发生；会有严重的性能损失，一般数据库不使用。一般事务只使用弱的隔离级别。</p><p><strong>读已提交</strong>：提供了两个保证</p><ul><li>从数据库读时，只能看到已提交的数据，没有脏读</li><li>写入数据库时，只能看到已提交的数据，没有脏写</li></ul><p>数据库使用 行锁 来防止脏写（两阶段锁协议）</p><p><strong>快照隔离 和 可重复读</strong>：一些情况下无法容忍同一个事务多次读的数据不一致（或一致性遭破坏）</p><ul><li>备份；如果备份了一部分新 一部分旧的数据，会破坏一致性</li><li>分析查询和完整性查询：需要扫描大量的数据，不一致的数据可能导致完整性损坏</li></ul><p>快照隔离的实现：</p><ul><li>使用写锁防止脏写</li><li>读取不需要加锁，性能方面：读不阻塞写，写不阻塞读</li><li>多版本并发控制（MVCC）：维护单个对象的多个版本，mysql 使用 undolog 实现访问旧版本；读已提交为每个查询使用单独的快照；可重复读（快照隔离）对整个事务使用相同的快照</li><li>每一行都有 created_by 和 deleted_by 字段，存储它被创建，被删除的事务ID</li><li>update 操作在内部被翻译成 delete 和 insert 操作</li></ul><p>事务 ID 决定了它能看到哪些对象：</p><ul><li>每次事务开始时，数据库列出当时其他（尚未提交或尚未中止）的事务清单，即使后续提交了，这些事务已执行的任何写入也都会被忽略</li><li>被终止事务写入的任何执行都会被忽略</li><li>有具有较晚事务的事务ID所作的任何写入都会被忽略</li><li>所有其他写入，对应用是可见的</li></ul><p>防止丢失更新的场景与办法：（事务执行顺序为 读 - 修改 - 写入序列，可能导致写入互相覆盖，丢失更新数据）</p><ul><li>原子写： <code>update x set val = val +1 where y=b;</code></li><li>显式锁定：<code>select * from xx where a = b for update;</code></li><li>自动检测丢失的更新：postgresql 的可重复读会自动检测丢失更新，并中止惹麻烦的事务；mysql 的 Innodb 不会。一些人认为<strong>能够自动检测丢失的跟更新</strong>才称得上是快照隔离</li><li>CAS，比较并设置，<code>update x set val=val2 where id=1 and val=valold;</code></li></ul><p><strong>写入偏差与幻读</strong>：案例：select count(*) from xx where a=b; 当 count > 2 时，写入一条新的 a=b 的数据；并发写入时，破坏了 count > 2 的约束条件。解决办法：</p><ul><li>使用 select for update，显式锁定</li><li>物化冲突。人为地在数据库中引入一组对象，用作锁。比如会议室预定的场景下，可以床架一个时间槽和房间槽的表，写入预定记录之间先使用 select for update 锁定槽位。</li></ul><p>可串行化有多种实现方案：单一线程顺序执行事务（性能低）、两阶段锁定、可串行化快照隔离。</p><p>可串行化的两阶段锁定：读会阻塞写，写会阻塞读；事务提交后释放锁；悲观锁，性能差。</p><p>可串行化的快照隔离方案：乐观锁；事务写入数据库时，必须在索引中查找最近读取的受影响数据的其他事务，如果数据已不是最新的，则中止事务。</p><h2 id=分布式系统的麻烦><a href=#%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9f%e7%9a%84%e9%ba%bb%e7%83%a6 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>分布式系统的麻烦</h2><p>分布式系统中容易发生<strong>部分失效</strong>（以某种不可知的方式被破坏）。部分失效是不确定性的：任何涉及到多个节点和网络的事情，它有可能会工作，有时会出现不可预知的失败。</p><p>不可靠的网络：当发出请求并期待响应，可能在任何节点任何阶段出错。处理这个问题的常用方法是<strong>超时</strong>。</p><p>不可靠的时钟。NTP 网络时间协议。它允许根据一组服务器报告的时间调整自己的时间。</p><ul><li>日历时钟：根据某个日历返回当前的时间，比如 unix 时间戳。日历时钟经常与 NTP 同步，可能导致时间回溯的情况。</li><li>单调时钟：它保证时间总是向前走的，适合测量持续时间（例如时间间隔），NTP 同步时，如果过快，则向前走的频率可以调低 0.05%，如果过慢，则可以调快 0.05%。单调钟可以是系统启动后的纳秒数。</li><li>逻辑时钟，使用递增计数器，而不是石英振荡器。</li></ul><p>真相由多数定义，通过投票以减少对某个特定节点的依赖。</p><p>一个 gc 导致锁失效，但代码继续执行覆盖了后续写入数据的案例：
<img loading=lazy src=/./img/gccauseerror.png alt=gcerror width=1124 height=436>
使用递增 token；比如使用 zookeeper 作为锁服务，可以使用 txid 或者节点的 cversion 作为令牌，因为它保证单调递增。</p><p><strong>拜占庭故障</strong>：有些节点可能因为延迟或其他原因，有意或无意发出错误消息 &ndash; 比如告知没有收到某条写请求。当一个系统中部分节点出现故障、不遵守协议、甚至恶意攻击、扰乱网络时仍能正常工作，称为拜占庭容错。常见系统：飞行控制系统，区块链系统。</p><p><strong>弱谎言形式</strong>：假定节点不会故意撒谎，使用防止撒谎的弱形式机制，比如：</p><ul><li>网络系统中的校验和，检测可能因为硬件或其他问题导致数据包损坏</li><li>校验用户的输入合法性</li><li>使用加权平均作为从多个分布式系统中同步的值，比如 币价/NTP时间</li></ul><p><strong>安全性：安全性被违反后，违规行为不能被撤销</strong> &ndash; 损失已经发生。比如 唯一性和单调序列属于安全性，如果产生了重复值，则系统损失已经发生，这个动作也不会恢复。<strong>活性：活性被破坏后，未来可能恢复</strong>，比如可用性，如果出现节点故障，暂时不可用，但未来也会是可用的。包括 最终一致性，也属于活性。</p><p><strong>算法的正确性建立在我们假设的系统之上</strong>，比如我们假设拜占庭故障节点数量低，所以算法才能成立，我们假定节点存储的数据不丢失，才能保证法定人数算法能够正确。 而现实世界可能会发生各种情况打破假设。 证明算法正确并不意味着它在真实系统中一定正确。</p><h2 id=一致性与共识><a href=#%e4%b8%80%e8%87%b4%e6%80%a7%e4%b8%8e%e5%85%b1%e8%af%86 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>一致性与共识</h2><p>大多数复制的数据库至少提供了<strong>最终一致性</strong>。</p><p><strong>线性一致性</strong>：<strong>数据库提供只有一个数据副本的假象</strong>，多个客户端在任何时候读取的数据，都能在某个时间点变更后，读到新数据。</p><p>依赖线性一致性的场景：</p><ul><li>锁定和领导选举；如果违反线性一致性，则可能出现脑裂</li><li>约束和唯一性保证</li><li>跨信道的时序依赖：比如上传完图片后，发送图片 url 到消息队列，异步任务处理消息获取 url 对应图片并处理，结果图片还未同步到其他节点，访问不到图片，或访问的是旧图片</li></ul><p><strong>CAP 定理</strong>：</p><ul><li>网络分区是一种故障类型，所以它并不是一个选项：它一定会发生</li><li>如果需要线性一致性，则发生副本掉线时，系统需要等待，期间不可用</li><li>如果应用不需要线性一致性，则某个副本断开后，也可以独立处理请求</li></ul><p>顺序保证了线性一致性，线性一致性包含了<strong>因果一致性</strong>。线性顺序是全序的，表现为系统中好像只有一个副本，而因果关系是偏序的，存在因果的两个事件是有序的，无因果关系的事件无序。线性一致性强于因果一致性。一个系统可以是因果一致的，而避免线性一致性带来的性能损耗。</p><p>为了确定因果顺序，数据库需要知道应用读取了那个版本的数据：</p><ul><li>比如写操作需要传入之前读操作得到的数据版本号</li><li>可串行化隔离快照中，数据库检查它读取的版本是否依然是最新的</li></ul><p><strong>兰伯特时间戳</strong>：由（计数器，节点ID）组成；计数器更大，时间戳更大；计数器相同，节点ID大的更大。
<img loading=lazy src=/./img/lanbotetime.png alt=lanbotetime width=1122 height=494></p><p><strong>全序广播</strong>满足两个安全属性：</p><ul><li>可靠交付：没有消息丢失，如果消息被传递到一个节点上，它将被传递到所有节点</li><li>全序交付：消息以相同的顺序传递到每个节点</li></ul><p>全序广播的重要表现：顺序在消息送达时被固化，如果后续的消息已经送达，节点就不允许追溯地将之前的消息插入顺序中较早位置。（解决了并发覆盖写导致数据不一致问题）</p><p>使用全序广播实现线性一致性存储。使用仅追加日志的方式实现这种 CAS 操作：</p><ol><li>在日志中追加一条消息，并试探性的指明你想要的用户名</li><li>读日志，并等待你刚才追加的消息被读回</li><li>检查是否有任何消息生成目标用户名的所有权，如果第一条是你的消息，则操作成功，你可以提交声称的用户名并向客户端确认。如果第一条消息来自其他用户，则中止操作。</li></ol><p>使用全序广播实现读取线性一致性的方案：</p><ul><li>可以先向日志中追加一条消息，直到消息被读回，才执行实际操作 &ndash; 此时说明读之前的消息已全部同步</li><li>查询最新消息的位置（如果允许的话），直到同步到此位置，再进行读取操作</li><li>从同步更新的副本中读取</li></ul><p><strong>两阶段提交</strong>使用一个通常不会出现在节点上的新组件：协调者（也叫事务管理器） &ndash; 它可能是客户端上的一个库，或一个进程，或一个单独的服务。协调者向所有参与者（节点）发送 prepare 请求：</p><ul><li>如果所有参与者都回答“是”，则协调者在第二阶段发出 commit 请求</li><li>如果任一参与者回答“否”，则协调者在第二阶段发出 abort 请求</li></ul><p>系统承诺：</p><ul><li>事务ID全局唯一</li><li>在参与者单节点事务上带上此事务ID</li><li>当应用准备提交，协调者向所有参与者发送 准备 请求，并打上全局事务ID 的标记。如果任一请求失败或超时，则协调者向所有参与者发送针对此事务ID的中止请求</li><li>参与者收到准备请求时，如果回答 是，则参与者需要确保只要请求，就一定能够提交</li><li>当协调者收到所有答复时，会对是否提交事务做出决定；协调者必须把决定写到磁盘的事务日志中，如果随后崩溃恢复，也能够知道自己做出的决定。这被称为提交点</li><li>一旦协调者的决定落盘，提交或放弃请求会发送给所有参与者。如果请求失败或超时，则必须一直重试下去</li></ul><p>协调者失效时，如果刚好有事务执行完第一阶段，未收到第二阶段的参与者节点会一直处于 存疑 状态，直到协调者回复。存疑时会一直持有锁，直到事务提交或中止。</p><p><strong>共识问题</strong>通常形式化如下：一个或多个节点可以提议（propose），而共识算法决定（decides）。共识算法必须满足以下性质：</p><ul><li>一致同意：没有两个节点的决定不同</li><li>完整性：没有节点决定两次</li><li>有效性：如果一个节点决定了值 v，则 v 由某个节点所倡议</li><li>终止：由所有未崩溃的节点来最终决定值</li></ul><p><strong>纪元编号与法定人数</strong>（raft 协议<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>）</p><ul><li>协定定义了一个纪元编号，并确保每个时代中，领导者都是唯一的</li><li>纪元编号是递增的，领导者被认为挂掉后，需要重新投票；两个不同时代的领导者之间出现冲突，更高纪元编号的说了算</li><li>必须从 法定人数 的节点中获取选票</li><li>两轮投票：第一次是为了选出领导者；第二次是对选出的领导者进行表决（类似两阶段提交）；这两次投票的法定人群必须相互重叠（即要求法定人数 > n/2）</li></ul><h2 id=批处理><a href=#%e6%89%b9%e5%a4%84%e7%90%86 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>批处理</h2><p>一个 MapReduce 作业和一个 Unix 进程相类比：它接收一个或多个输入，并产生一个或多个输出。MapReduce 在分布式系统上读写文件 &ndash; HDFS Hadoop 分布式文件系统。</p><p>HDFS 在每台机器上运行了一个守护进程，它对外暴露网络服务，允许其他节点访问存储在该机器上的文件。名为 NameNode 的中央服务器会跟踪那个文件块存储在哪个机器上。为了容忍机器和硬盘故障，文件被复制到多台机器上。</p><p><strong>MapReduce</strong> 基本工作流程：输入格式解析器处理输入；Mapper 函数提取键值对；输出数据到 Reducer 时会自动按照键值对排序；Reducer 处理每个键的所有值。</p><p>Mapper：Mapper 会在每条输入记录上调用一次，从每条输入记录上提取键值。对于每个输入可以生成任意数量的键值对，包括 None。无状态，每条记录是独立的。</p><p>Reducer：MapReduce 框架拉取由 Map 生成的键值对，收集属于同一个键的所有值，并在这组值上迭代调用 Reducer。Reducer 可以产生输出记录。</p><p>将计算放在数据附近：每个输入文件的大小通常是几百兆，MapReduce 调度器试图在每台存储输入文件副本的机器上运行每个 Mapper。节省了网络复制输入文件的开销。</p><h2 id=流处理><a href=#%e6%b5%81%e5%a4%84%e7%90%86 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>流处理</h2><p>在流处理中，一个事件由生产者产生一次，然后可能由多个消费者处理。相关的事件通常被聚合成一个主题（topic）或流（stream）。</p><p>消息传递系统的方案：</p><ul><li>直接从生产者传递给消费者：UDP、无代理的消息库 ZeroMQ nanomsg 等、通过 http 或者 rpc 传递给消费者（webhook）</li><li>消息代理：kafka、redis等</li></ul><p><strong>消息代理</strong>：</p><ul><li>通常 消息传递给消费者后会自动删除（或保存一段时间后删除）</li><li>队列工作集比较小，比如 kafka 默认保存 7 天</li><li>支持按照某种模式匹配主题，订阅其子集</li><li>不支持任何查询，通常只能流式订阅</li></ul><p>多个消费者从同一主题读取消息的模式：负载均衡，每个消息被传递给消费者之一；扇出（fan-out），每个消息被传递给所有消费者。</p><p>确认与重新传递：客户端显式告知消息代理 消息已经处理完毕。</p><p>分区日志：基于日志的消息代理。对日志进行分区，存储在不同的机器上；每个分区内，消息被分配一个单调递增的序列号（或偏移量）。记录消费者消费某个分区消息的进度，称为消费者偏移量。</p><p>当消费者跟不上生产者时：丢弃消息、进行缓冲、施加背压，影响生产者的速度。可以监控消费者落后日志头部的距离，落后太多就发出报警。</p><p>保持多系统数据同步的方式：</p><ul><li><strong>双写</strong>：比如写入数据库时，同时写入数据库和缓存/ES。但并发写入到每个系统的时间不一致，发生冲突导致系统数据不一致</li><li><strong>变更数据捕获（CDC）</strong>：捕获数据库的变更日志，通过消息代理给多个系统消费，同步数据</li></ul><p>系统变更事件是不可变的，所以可以从事件日志派生出当前状态。</p><p>流处理的一些场景：</p><ul><li>复合事件处理</li><li>流分析，例如 prometheus（滚动计算、区间对比统计、测试事件速率）</li><li>维护物化视图：缓存，搜索索引，数据仓库</li><li>在流上搜索：先构建搜索查询，再在流数据上跑查询</li><li>消息传递和 rpc</li></ul><p>流分析的时间窗口类型：</p><ul><li>滚动窗口：每个事件只能属于一个窗口，比如 一分钟一个窗口</li><li>跳动窗口：固定长度，但允许窗口部分重叠，例如：一个步长为 1 的，长度为 5 的跳动窗口</li><li>滑动窗口：跟跳动相比，没有步长的概念，不断往窗口添加新数据，移除旧数据</li><li>会话窗口：没有固定持续时间，将一个用户出现时间相近的事件联系在一起</li></ul><p><strong>流流连接</strong>：在处理流数据时，需要额外的数据库存储流事件，以便另一个事件到达后能够查询到此事件。
<strong>流表连接</strong>：创建事件时，把数据库副本数据写入到事件里，这样处理事件时不用查询数据库；或者处理事件时查询数据库。</p><p>流处理中的容错手段：微批次和存档点、使用事务原子提交、幂等性、失败后重建状态。</p><h2 id=数据系统的未来><a href=#%e6%95%b0%e6%8d%ae%e7%b3%bb%e7%bb%9f%e7%9a%84%e6%9c%aa%e6%9d%a5 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>数据系统的未来</h2><p><strong>组合使用衍生数据的工具</strong>，比如搜索引擎/缓存/分析型数据库。分布式事务性能较低，容错能力差，但提供线性一致性，读己之写；衍生数据通常是异步的，提供最终一致性。</p><p><strong>组合使用数据库存储技术</strong>：次级索引、物化视图、复制日志、全文搜索引擎。</p><p><strong>联合数据库</strong>：统一读取。为各种各样的底层存储引擎和处理方法提供统一的查询接口；例如 PostgreSQL 的外部数据包装器。<strong>分拆数据库</strong>：统一写入；变更日志捕获衍生到其他系统。</p><p>将事情做正确：</p><ul><li>端到端原则：只有在通信系统两端应用的知识和帮助下，所讨论的功能才能完全正确的实现。比如 tcp 两端需要记录维护序列号；比如幂等操作需要两端都保证唯一标识符。</li><li>强制约束。唯一性约束需要达成共识：最常见的方式是使用单节点作为领导，负责所有决策；全序广播；分区依赖消息日志进行处理。</li><li>及时性与完整性。事务通常提供一致性：一致性实际包含 及时性（线性一致性，读己之写）和完整性。</li><li>信任但验证。不要盲目信任承诺。审计，审查数据完整性。</li></ul><p>做正确的事情：预测性分析可能存在的偏见与歧视，推荐系统的责任问题，反馈循环功能。隐私与追踪需要符合法律法规，防止用户数据滥用，允许用户选择是否同意上传个人数据等。</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>《Designing Data-Intensive Applications》Martin Kleppmann. 中文翻译 <a href=http://ddia.vonng.com/>http://ddia.vonng.com/</a> 冯若航 （@Vonng）&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>分形树 <a href=https://en.wikipedia.org/wiki/Fractal_tree_index>https://en.wikipedia.org/wiki/Fractal_tree_index</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>raft 协议动画演示 <a href=http://thesecretlivesofdata.com/raft/>http://thesecretlivesofdata.com/raft/</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></div><div class=container><nav class="flex container suggested"><a rel=prev href=/posts/read-sicp/ title="Previous post (older)"><span>Previous</span>
读《计算机程序的构造和解释》</a></nav></div><div class=container><script src=https://giscus.app/client.js data-repo=xiang-xx/xiang-xx.github.io data-repo-id=R_kgDOI4YfdA data-category=Comment data-category-id=DIC_kwDOI4YfdM4CT7aL data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-theme=light crossorigin=anonymous async></script><script>function setGiscusTeheme(e){let t=document.querySelector(".giscus iframe");t&&t.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}addEventListener("message",e=>{if(e.origin!=="https://giscus.app")return;setGiscusTeheme(document.documentElement.dataset.userColorScheme)}),window.addEventListener("onColorSchemeChange",e=>{setGiscusTeheme(e.detail)})</script></div></main></main><footer class="footer flex"><section class=container><nav class=footer-links><a href=/index.xml>RSS</a></nav></section><script defer src=/ts/features.706a523ba43e6d0427c7fdf2b9d05dbd0920d3f12942b453690b495cb2522743.js data-enable-footnotes=true></script></footer></body></html>
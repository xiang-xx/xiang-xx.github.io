<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=theme-color content="dark"><title>Golang 运行时探究 | XX Blog</title><meta property="og:site_name" content="XX Blog"><meta property="og:title" content="Golang 运行时探究 | XX Blog"><meta itemprop=name content="Golang 运行时探究 | XX Blog"><meta name=twitter:title content="Golang 运行时探究 | XX Blog"><meta name=application-name content="Golang 运行时探究 | XX Blog"><meta name=twitter:card content="summary"><meta name=description content="从源码入手，了解 golang 运行时工作流程"><meta name=twitter:description content="从源码入手，了解 golang 运行时工作流程 "><meta itemprop=description content=" 从源码入手，了解 golang 运行时工作流程 "><meta property="og:description" content=" 从源码入手，了解 golang 运行时工作流程 "><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=stylesheet href=/sass/main.min.ab99ff095f832511e24ffb2fba2b51ad473b2f7e9301d674eba2c6c3a6e8bd81.css></head><script>(function(){const e="ThemeColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="ThemeColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.userColorScheme="dark":document.documentElement.dataset.userColorScheme="light"})()</script><body class=dark><nav class=navbar><div class=container><div class=flex><div><a class=brand href=/><img src=/favicon.ico>
XX Blog</a></div><div class=flex><a href=/archives/>归档</a>
<a href=/posts/>文章</a>
<button id=dark-mode-button><svg class="light" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform:rotate(360deg);-webkit-transform:rotate(360deg);transform:rotate(360deg)" viewBox="0 0 36 36"><path fill="#ffd983" d="M30.312.776C32 19 20 32 .776 30.312c8.199 7.717 21.091 7.588 29.107-.429C37.9 21.867 38.03 8.975 30.312.776z"/><path d="M30.705 15.915a1.163 1.163.0 101.643 1.641 1.163 1.163.0 00-1.643-1.641zm-16.022 14.38a1.74 1.74.0 000 2.465 1.742 1.742.0 100-2.465zm13.968-2.147a2.904 2.904.0 01-4.108.0 2.902 2.902.0 010-4.107 2.902 2.902.0 014.108.0 2.902 2.902.0 010 4.107z" fill="#ffcc4d"/><rect x="0" y="0" width="36" height="36" fill="rgba(0, 0, 0, 0)"/></svg><svg class="dark" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="1em" height="1em" style="-ms-transform:rotate(360deg);-webkit-transform:rotate(360deg);transform:rotate(360deg)" viewBox="0 0 36 36"><path fill="#ffd983" d="M16 2s0-2 2-2 2 2 2 2v2s0 2-2 2-2-2-2-2V2zm18 14s2 0 2 2-2 2-2 2h-2s-2 0-2-2 2-2 2-2h2zM4 16s2 0 2 2-2 2-2 2H2s-2 0-2-2 2-2 2-2h2zm5.121-8.707s1.414 1.414.0 2.828-2.828.0-2.828.0L4.878 8.708s-1.414-1.414.0-2.829c1.415-1.414 2.829.0 2.829.0l1.414 1.414zm21 21s1.414 1.414.0 2.828-2.828.0-2.828.0l-1.414-1.414s-1.414-1.414.0-2.828 2.828.0 2.828.0l1.414 1.414zm-.413-18.172s-1.414 1.414-2.828.0.0-2.828.0-2.828l1.414-1.414s1.414-1.414 2.828.0.0 2.828.0 2.828l-1.414 1.414zm-21 21s-1.414 1.414-2.828.0.0-2.828.0-2.828l1.414-1.414s1.414-1.414 2.828.0.0 2.828.0 2.828l-1.414 1.414zM16 32s0-2 2-2 2 2 2 2v2s0 2-2 2-2-2-2-2v-2z"/><circle fill="#ffd983" cx="18" cy="18" r="10"/><rect x="0" y="0" width="36" height="36" fill="rgba(0, 0, 0, 0)"/></svg></button></div></div></div></nav><main><div class=container><article><header class=article-header><div class=thumb><div><h1>Golang 运行时探究</h1><div class=post-meta><div>By Xiang | <time>March 05, 2023</time>
| 6 minutes</div><div class=tags><a href=/tags/golang/>golang</a></div></div></div></div></header></article><div class=article-post><blockquote><p>版本与原型环境：Golang: 1.19.6; WSL2 Ubuntu-20.04</p></blockquote><p>本文尽量不放过多源码，只注明源码位置及大致逻辑，开发者还需要自己阅读源码才能对 runtime 有更深刻的体会。runtime 代码都在 <a href=https://github.com/golang/go/tree/master/src/runtime>src/runtime</a> 目录下。</p><h2 id=启动阶段><a href=#%e5%90%af%e5%8a%a8%e9%98%b6%e6%ae%b5 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>启动阶段</h2><p>Debug 运行一段最简单的代码，观察一下程序刚启动后的调用堆栈：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;hello world&#34;</span><span class=p>)</span>  <span class=c1>// 程序停在这
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>观察程序的 Call Stack，可以发现启动了五个协程，根据调用栈可以找到这五个协程对应的入口:</p><ul><li><code>runtime.main</code>，它调用了我们定义的 main 函数，是用户程序的入口</li><li><code>runtime.forcegchelper</code>，gc 辅助协程，它在 proc.go 的 <code>runtime.init</code> 中被调用</li><li><code>runtime.bgsweep</code>，gc 标记，在 <code>runtime.gcenable</code> 中被启动</li><li><code>runtime.bgscavenge</code>，gc 清除，也在 <code>runtime.gcenable</code> 中被启动；<code>runtime.gcenable</code> 在 <code>runtime.main</code>中被调用</li><li><code>runtime.runfinq</code>，它是运行所有 <code>finalizers</code> 的协程，它只被启动一次，会在第一次调用 <code>runtime.SetFinalizer</code> 时被启动。用户自定义的所有 Finalizer 都会在这个写成立串行执行，所以要在 Finalizer 里执行耗时操作，最好启动新的协程。</li></ul><p>以上只是在 go 的层面观察到的启动顺序。Go 程序启动的最初入口在汇编代码层面，主要是在 <code>runtime.rt0_go</code> 汇编函数中<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-s data-lang=s><span class=line><span class=cl><span class=n>TEXT</span> <span class=n>runtime</span>·<span class=nf>rt0_go</span><span class=p>(</span><span class=n>SB</span><span class=p>),</span><span class=n>NOSPLIT</span><span class=o>|</span><span class=n>TOPFRAME</span><span class=p>,</span><span class=o>$</span><span class=m>0</span>
</span></span><span class=line><span class=cl>	<span class=o>//</span> <span class=kc>...</span>
</span></span><span class=line><span class=cl><span class=n>nocgo</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=o>//</span> 创建 <span class=n>m0</span> 和 <span class=n>g0</span> 并相互引用
</span></span><span class=line><span class=cl>	<span class=o>//</span> <span class=n>save</span> <span class=n>m</span><span class=o>-&gt;</span><span class=n>g0</span> <span class=o>=</span> <span class=n>g0</span>
</span></span><span class=line><span class=cl>	<span class=n>MOVD</span>	<span class=n>g</span><span class=p>,</span> <span class=nf>m_g0</span><span class=p>(</span><span class=n>R0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=o>//</span> <span class=n>save</span> <span class=n>m0</span> <span class=n>to</span> <span class=n>g0</span><span class=o>-&gt;</span><span class=n>m</span>
</span></span><span class=line><span class=cl>	<span class=n>MOVD</span>	<span class=n>R0</span><span class=p>,</span> <span class=nf>g_m</span><span class=p>(</span><span class=n>g</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=o>//</span> 初始化：执行文件路径，内存页大小
</span></span><span class=line><span class=cl>	<span class=n>BL</span>	<span class=n>runtime</span>·<span class=nf>args</span><span class=p>(</span><span class=n>SB</span><span class=p>)</span>   <span class=o>//</span> <span class=n>runtime1.go</span><span class=o>/</span><span class=n>args</span>
</span></span><span class=line><span class=cl>    <span class=o>//</span> <span class=n>CPU</span> 个数，大页内存页大小
</span></span><span class=line><span class=cl>	<span class=n>BL</span>	<span class=n>runtime</span>·<span class=nf>osinit</span><span class=p>(</span><span class=n>SB</span><span class=p>)</span>  <span class=o>//</span> <span class=n>os_linux.go</span><span class=o>/</span><span class=n>osinit</span>
</span></span><span class=line><span class=cl>    <span class=o>//</span> 命令行参数、环境变量、<span class=n>gc</span>、栈空间、内存管理、所有<span class=n>P</span>实例、<span class=n>HASH</span>算法等
</span></span><span class=line><span class=cl>	<span class=n>BL</span>	<span class=n>runtime</span>·<span class=nf>schedinit</span><span class=p>(</span><span class=n>SB</span><span class=p>)</span>  <span class=o>//</span> <span class=n>proc.go</span><span class=o>/</span><span class=n>schedinit</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=o>//</span> <span class=n>create</span> <span class=n>a</span> <span class=n>new</span> <span class=n>goroutine</span> <span class=n>to</span> <span class=n>start</span> <span class=n>program</span>
</span></span><span class=line><span class=cl>    <span class=o>//</span> 创建一个新的 <span class=n>goroutine</span>，绑定 <span class=n>runtime.main</span>，放在 <span class=n>P</span> 本地队列，等待调度
</span></span><span class=line><span class=cl>	<span class=n>MOVD</span>	<span class=o>$</span><span class=n>runtime</span>·<span class=nf>mainPC</span><span class=p>(</span><span class=n>SB</span><span class=p>),</span> <span class=n>R0</span>		<span class=o>//</span> <span class=n>entry</span>
</span></span><span class=line><span class=cl>	<span class=n>SUB</span>	<span class=o>$</span><span class=m>16</span><span class=p>,</span> <span class=n>RSP</span>
</span></span><span class=line><span class=cl>	<span class=n>MOVD</span>	<span class=n>R0</span><span class=p>,</span> <span class=m>8</span><span class=p>(</span><span class=n>RSP</span><span class=p>)</span> <span class=o>//</span> <span class=n>arg</span>
</span></span><span class=line><span class=cl>	<span class=n>MOVD</span>	<span class=o>$</span><span class=m>0</span><span class=p>,</span> <span class=m>0</span><span class=p>(</span><span class=n>RSP</span><span class=p>)</span> <span class=o>//</span> <span class=n>dummy</span> <span class=n>LR</span>
</span></span><span class=line><span class=cl>	<span class=n>BL</span>	<span class=n>runtime</span>·<span class=nf>newproc</span><span class=p>(</span><span class=n>SB</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>ADD</span>	<span class=o>$</span><span class=m>16</span><span class=p>,</span> <span class=n>RSP</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=o>//</span> 启动 <span class=n>M</span>，开始调度 <span class=n>goroutine</span>
</span></span><span class=line><span class=cl>	<span class=n>BL</span>	<span class=n>runtime</span>·<span class=nf>mstart</span><span class=p>(</span><span class=n>SB</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>初始化过程做了很多事情，包括对于 android、ios 以及其他窗口应用的一些前置逻辑。用 <code>schedinit</code> 函数的注释说，启动顺序是：</p><ul><li>call osinit</li><li>call schedinit</li><li>make & queue new G, The new G calls runtime·main.</li><li>call runtime.mstart</li></ul><p>我们主要关注 <code>schedinit</code> 和 <code>runtime.main</code>。</p><p><code>schedinit</code> 的几个主要的初始化动作：</p><ul><li>初始化系统全局锁的 lock rank：系统层面的锁有很多，有些操作需要获取多个锁，对锁按照 rank 排序，防止死锁。</li><li>设置 <code>sched.maxmcount = 10000</code>，即 <code>G-M-P</code> 模型中 <code>M</code> 的最大数量（超出时会 panic）</li><li><code>mallocinit</code>，包含若干内存管理过程<ul><li><code>mheap_.init()</code> 用于初始化 <code>span</code> 分配器、<code>cache</code> 分配器及其他特殊分配器，以及初始化 136 个对应 <code>spanClass</code> 的中央缓存 <code>mheap.central[136]</code>，最后是向操作系统申请内存；这些内存分配器都是 <code>fixalloc</code> 的实例，<code>fixalloc</code> 用于固定大小对象的空闲列表分配器。</li><li>使用 <code>cache</code> 分配器初始化 <code>mcache0</code>，用于初始化时候分配内存，后续会绑定到第一个 <code>P</code></li><li>初始化 <code>mheap_.arenaHints</code>，用于设置申请更多 <code>heap areanas</code> 后的地址（go runtime 定义的内存地址）</li></ul></li><li><code>cpuinit</code> 读取 <code>GODEBUG</code> 环境变量并初始化 cpu 信息</li><li><code>alginit</code> 随机初始化 <code>hash</code> 算法种子</li><li><code>fastrandinit</code> 初始化随机算法种子</li><li><code>modulesinit</code> 从所有加载的 <code>module</code> 中创建 <code>activeModules</code> 切片</li><li><code>typelinksinit</code> 加载 <code>activeModules</code> 定义的类型</li><li><code>goargs</code> 初始化命令行 <code>args</code></li><li><code>goenv</code> 初始化 <code>env</code></li><li><code>gcinit</code> 初始化 <code>gc work</code> 状态，以及对应锁的 <code>rank</code></li><li><code>procresize</code> 设置 <code>P</code> 的数量，创建 <code>P</code> 并初始化 <code>P</code>（如果 <code>P</code> 数量变少，则销毁对应数量的 <code>P</code>），第一个创建的 <code>P</code> 的 <code>P.mcache = mcache0</code>，后续的 <code>P.mcache = allocmcache()</code>，即从 <code>mheap</code> 中申请新的 <code>mcache</code>；给当前 <code>g.m</code> 绑定一个 P；<code>mcache0 = nil</code> 全局 <code>mcache0</code> 不再持有该内存指针；<code>p.m.set(mget())</code> 尝试给 <code>P</code> 绑定一个 <code>M</code>；</li><li><code>worldStarted</code> <code>P</code> 可以运行了</li></ul><p><code>runtime.main</code> 的主要流程：</p><ul><li>设置最大栈空间大小：64 位系统 1GB，32 位系统 250M，</li><li>创建 <code>sysmon</code> 线程，辅助垃圾清扫，协程调度</li><li><code>doInit(runtime_inittask)</code> 调用 <code>runtime init</code> 函数</li><li><code>gcenable</code> 启动 gc 协程 <code>bgsweep</code> <code>bgscavenge</code></li><li><code>doInit(main_inittask)</code> 调用用户程序 <code>init</code> 函数</li><li><code>fn := main_main; fn()</code> 调用 <code>main</code> 函数</li><li><code>main</code> 函数返回后，函数退出</li></ul><p>总的来说，初始化阶段可以分为两部分，第一部分是系统环境初始化：系统锁顺序、内存分配器、堆内存、最初的 <code>mcache0</code>、<code>hash</code> 与 随机算法、环境参数、<code>process</code> 等，第二部分是运行环境初始化：运行环境所需的 <code>sysmon</code> 线程（不绑定 <code>P</code>，不在 <code>G-M-P</code> 模型内调度）、垃圾标记与清扫协程、<code>runtime</code> 与用户程序的 <code>init</code>，以及最后启动 <code>main</code> 函数。</p><h2 id=运行阶段><a href=#%e8%bf%90%e8%a1%8c%e9%98%b6%e6%ae%b5 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>运行阶段</h2><h3 id=内存模型><a href=#%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>内存模型</h3><p>Go 使用 <code>mheap</code> 管理所有堆内存。向操作系统申请的最小内存单元是 <code>page</code>，go 程序每次向操作系统申请若干 <code>page</code>，并使用 <code>heapArena</code> 管理 <code>mheap</code> 中 <code>page</code> 的状态。从 <code>mheap</code> 中申请内存的最小单位是 <code>mspan</code>，它由若干 <code>page</code> 组成。</p><p><code>mspan</code> 根据存储的单个 <code>object</code> 的内存大小划分为不同的 <code>spanClass</code>，比如有的用于存储小对象，有的用于储存较大的对象；这种划分划分方式既能提高可用内存的查找效率，又能提高空间利用率，避免过多空间碎片。</p><p>每个 <code>mspan</code> 都在一个双向链表中，可能是 <code>mheap</code> 的 <code>busy list</code>，或者是某个 <code>mcentral</code> 的 <code>span list</code>。</p><p>一些关键对象字段：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>mheap</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>pages</span> <span class=nx>pageAlloc</span> <span class=c1>// page allocation data structure
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>allspans</span> <span class=p>[]</span><span class=o>*</span><span class=nx>mspan</span> <span class=c1>// all spans out there
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>arenas</span> <span class=p>[</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=nx>arenaL1Bits</span><span class=p>]</span><span class=o>*</span><span class=p>[</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=nx>arenaL2Bits</span><span class=p>]</span><span class=o>*</span><span class=nx>heapArena</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 中心缓存
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>central</span> <span class=p>[</span><span class=nx>numSpanClasses</span><span class=p>]</span><span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>mcentral</span> <span class=nx>mcentral</span>
</span></span><span class=line><span class=cl>		<span class=nx>pad</span>      <span class=p>[</span><span class=nx>cpu</span><span class=p>.</span><span class=nx>CacheLinePadSize</span> <span class=o>-</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Sizeof</span><span class=p>(</span><span class=nx>mcentral</span><span class=p>{})</span><span class=o>%</span><span class=nx>cpu</span><span class=p>.</span><span class=nx>CacheLinePadSize</span><span class=p>]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>mcentral</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>spanclass</span> <span class=nx>spanClass</span>
</span></span><span class=line><span class=cl>	<span class=nx>partial</span> <span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=nx>spanSet</span> <span class=c1>// list of spans with a free object
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>full</span>    <span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=nx>spanSet</span> <span class=c1>// list of spans with no free objects
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>mheap_</span> <span class=nx>mheap</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>mspan</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>next</span> <span class=o>*</span><span class=nx>mspan</span>     <span class=c1>// next span in list, or nil if none
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>prev</span> <span class=o>*</span><span class=nx>mspan</span>     <span class=c1>// previous span in list, or nil if none
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>list</span> <span class=o>*</span><span class=nx>mSpanList</span> <span class=c1>// For debugging. TODO: Remove.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>startAddr</span> <span class=kt>uintptr</span> <span class=c1>// address of first byte of span aka s.base()
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>npages</span>    <span class=kt>uintptr</span> <span class=c1>// number of pages in span
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>freeindex</span> <span class=kt>uintptr</span>
</span></span><span class=line><span class=cl>	<span class=nx>nelems</span> <span class=kt>uintptr</span> <span class=c1>// number of object in the span.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=栈空间管理><a href=#%e6%a0%88%e7%a9%ba%e9%97%b4%e7%ae%a1%e7%90%86 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>栈空间管理</h3><p>每个 <code>G</code> 有自己的栈空间。调用 <code>proc.go/newproc()</code> 创建新的协程，程序会尝试从本地 <code>P.gFree</code> 和全局 <code>sched.gFree</code> 获取一个 <code>dead G</code>（被回收的 <code>G</code>），则直接复用它的栈。如果没有 <code>dead G</code>，则调用 <code>malg(stackMin)</code> 创建一个拥有最小栈空间 2048 的 <code>G</code>。</p><p>编译器会为函数调用插入 <code>runtime.morestack</code> 检查，如果栈空间不足，需要扩容<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>，则会调用 <code>runtime.newstack</code> 扩容。<code>newsize := oldsize * 2</code>，每次容量增加一倍；程序会检查 <code>newsize</code> 是否符合新栈空间要求，如果不够，继续增大 <code>newsize</code>。调用 <code>copystack(gp *g, newsize uintptr)</code> 申请新的栈空间，并复制栈内容，把新栈指针设置到 <code>g</code>，<code>stackfree(old)</code> 回收旧栈。</p><p><code>stack.go/stackalloc(n uint32)</code> 用于申请新的栈内存，主要逻辑为：</p><ul><li>如果 GODEBUG 设置 efence != 0，或 stackFromSystem !=0，则直接从系统内存中申请一段内存</li><li>如果 n 小于 <code>_StackCacheSize = 32768</code>，且小于 <code>_FixedStack&lt;&lt;_NumStackOrders</code>（随系统变化），则尝试从本地或去全局 <code>stack</code> 缓存获取：<ul><li>如果当前 g.m 没有 p，或 p 不使用 <code>stackcache</code>，则调用 <code>stackpoolalloc</code> 从全局 <code>stackpool</code> 中获取，<code>stackpool</code> 没有可用缓存时，调用 <code>mheap._allocManual</code> 从 <code>mheap</code> 中申请。</li><li>否则，从当前 P 的 <code>mcache.stackcache</code> 申请，如果 <code>mcache.stackcache</code> 为空，则调用 <code>stackpoolalloc</code> 从全局 <code>stackpool</code> 获取，直到 <code>mcache.stackcache</code> 填充一半（<code>size >= _StackCacheSize/2</code>）</li></ul></li><li>先尝试从全局 <code>stackLarge</code> 缓存中获取，如果没有，则直接从 mheap 中调用 <code>mheap_.allocManual</code> 申请包含若干 <code>page</code> 的 <code>span</code>。</li></ul><p>在 gc 扫描栈的过程中，可能发生栈缩容，栈缩容与扩容类似，计算目标栈空间大小，调用 <code>copystack(gp *g, newsize uintptr)</code> 申请新的栈空间，并复制栈内容，把新栈指针设置到 g，<code>stackfree(old)</code> 回收旧栈。</p><p><code>stackfree</code> 的逻辑与 <code>stackalloc</code> 类似：</p><ul><li>若 n 小于 <code>_StackCacheSize = 32768</code>，且小于 <code>_FixedStack&lt;&lt;_NumStackOrders</code>，则尝试回收到全局 <code>stackpool</code> 或者 <code>p.mcache.stackcache</code>，回收过程也会根据各级缓存是否已满，则回收到上级缓存，直到最后回收到 <code>mheap</code><ul><li>只有在 <code>_GCoff</code> 阶段才能向 <code>mheap</code> 直接回收栈空间</li></ul></li><li>若 n 比较大，则根据 GC 阶段判断回收到哪里：<ul><li><code>gcphase == _GCoff</code>：GC 没有运行，后台清扫中，没有开启写屏障，则直接回收到 <code>mheap</code></li><li>GC 运行时，为了避免 <code>span</code> 回收到 <code>mheap</code> 后，又被申请用作堆 <code>span</code>，可能与 gc 发生冲突，所以直接回收到 <code>stackLarge</code> 缓存。</li></ul></li></ul><p>总结一下，较小的栈存在两级缓存：本地 <code>P</code> 缓存 <code>P.mcache.stackcache</code>、全局 <code>stackpool</code>；大的栈空间存在一级缓存：<code>stackLarge</code>；申请缓存时根据条件分别尝试从各级缓存中申请，从全局或 mheap 申请/释放时否需要加锁，所以会优先尝试本地 <code>P.mcache.stackcache</code>。释放缓存时，避免在 GC 时，栈 <code>span</code> 回收到 <code>mheap</code> 后又被申请为堆 <code>span</code>，导致状态冲突，所以 GC 时不能向 <code>mheap</code> 回收栈内存，最多只回收到全局栈缓存。</p><p>此外，各级缓存都会根据栈空间大小（扩容次数），或栈的 <code>page</code> 数量（large stack），划分为不同的链表（例如类型为：<code>stackcache[size or page count] stackfreelist</code>）进行管理，方便快速找到对应大小的占空间。</p><h3 id=堆内存申请><a href=#%e5%a0%86%e5%86%85%e5%ad%98%e7%94%b3%e8%af%b7 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>堆内存申请</h3><p>以下情况，对象的内存会被分配到堆上 <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>：</p><ul><li>内存原因：<code>interface{}</code> 动态类型，编译期无法知道内存大小；栈空间不足，比如创建一个超过系统栈空间大小的数组</li><li>作用域原因：闭包或协程访问外部作用域；函数内创建的指针返回到外部；指针被堆上的对象引用</li></ul><p>堆内存申请的入口在 <code>malloc.go/mallocgc(size uintptr, typ *_type, needzero bool)</code>，根据此函数注释可以了解到：</p><ul><li>小对象从本地 <code>P</code> 的缓存中申请</li><li>大对象（> 32kB）直接从 <code>mheap</code> 中申请</li></ul><p>内存申请的主要逻辑为：</p><ul><li>如果申请内存大小 <code>size</code> 为 0，则直接返回一个固定的 <code>zeroAddr</code></li><li>获取当前线程 m 的乐观锁，<code>m.mallocing = 1</code></li><li>如果类型 typ 内没有指针，且小于 <code>maxTinySize</code> 16 字节，则尝试从当前 <code>P.mcache</code> 的 <code>tinyAllocs</code> 申请内存（<code>tinyAllocs</code> 内存申请只需要计算在 tiny 缓存区的偏移量，性能很高）；没有 tiny 缓存，则依次尝试向 <code>mcache.alloc[tinySpanclass]</code> 及其上级缓存申请</li><li>如果 <code>size &lt;= maxSmallSize</code> 32kB，则计算 size 对应的 <code>spanClass</code>，并一次尝试向 <code>mcache.alloc[tinySpanclass]</code> 及其上级缓存申请，具体逻辑为：<ul><li>先调用 <code>span = c.alloc[spanClass]; v = nextFreeFast(span)</code> 从 span 双向链表的当前 span 节点中，使用 <code>allocCache</code> 标志位快速查找是否存在未使用的缓存，如果有，则直接用此缓存</li><li>否则，调用本地缓存 <code>mcache.nextFree(spanClass)</code>，此方法先尝试从 <code>span.freeIndex</code> 之后查找可用缓存，如果没有，说明 span 已满；则调用 <code>mcache.refill(spanClass)</code> 从全局缓存 <code>mheap.central[spanClass]</code> 中申请一块有剩余缓存的 span，并调用新 <code>span.nextFreeIndex</code> 得到内存指针。如果需要从全局缓存获取，则 <code>shouldhelpgc</code> 设置为 true，后续会触发 GC。<code>central[spanClass]</code> 用尽时，会调用 <code>mheap_.alloc(npages, spanclass)</code> 从 mheap 中申请一个有 <code>npages pages</code> 的 <code>span</code>（span 根据 spanClass 有不同的大小，多个 pages 组成一个 span）。</li></ul></li><li>如果 <code>size > maxSmallSize</code> 32kB，则通过 <code>mcache.allocLarge</code> 方法，调用 <code>mheap_.alloc(npages, spanclass)</code> 直接向 <code>mheap</code> 中申请若干 <code>pages</code>，组成 <code>span</code> 并返回。<code>shouldhelpgc</code> 设置为 <code>true</code>，后续会触发 GC。</li></ul><p>总结一下，申请无指针的小对象时有 <code>tinyAlloc</code> 优化措施，中等对象优先尝试从当前 <code>P.mcache</code> 中申请，没有则依次向全局缓存 <code>mheap.central mheap</code> 中申请，大对象直接从 <code>mheap</code> 中申请。申请过程中，如果 <code>P.mcache</code> 用尽或申请了大对象，都会触发 GC。内存的释放在 GC 过程。</p><h3 id=垃圾回收><a href=#%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>垃圾回收</h3><p>GC 开始的入口在 <code>mgc.go/gcStart(gcTrigger)</code>，查看此函数的所有调用可以了解到 GC 触发的场景有:</p><ul><li>堆内存申请时 <code>P.mcache</code> 用尽，或申请了大于 32kB 的对象</li><li>用户程序调用 <code>runtime.GC()</code></li><li><code>forcegchelper</code> 协程定时触发 GC</li></ul><p>Go 的三色标记法的大致流程：短暂 STW，为每个 <code>P</code> 上创建一个 <code>G</code>，用于垃圾回收的标记阶段；标记阶段完成后，触发清扫阶段，清扫阶段需要 STW。标记阶段采用三色标记法：<strong>先把所有的根对象标记为灰色并放到任务队列，然后持续从任务队列取出灰色对象，并标记为黑色，把它的指针指向的对象标记为灰色，入工作队列，持续此过程直到工作队列为空</strong>；为了防止标记协程与用户协程出现并发问题，使用混合写屏障<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>将被覆盖的对象标记成灰色，并在当前栈没有扫描时将新对象也标记成灰色；在 <code>mallocgc</code> 函数里，把新创建的对象标记为黑色。</p><p>垃圾回收入口 <code>gcStart</code> 的主要流程：</p><ul><li>启动与 <code>P</code> 数量相同的协程用于并发标记，每个 <code>P</code> 上跑一个标记协程 <code>gcBgMarkWorker</code></li><li><code>stopTheWorldWithSema</code> 暂停世界</li><li>处理一些 GC 前置的工作，例如 GC、CPU 限制，GC 状态修改，初始化堆标记 work（标记的工作队列），标记 <code>TinyObjects</code> 等</li><li><code>startTheWorldWithSema</code> 继续调度协程，<code>gcBgMarkWorker</code> 被调度后会进行标记动作</li></ul><p>标记协程 <code>gcBgMarkWorker</code> 流程：</p><ul><li>通过 <code>gcController.findRunnableGCWorker</code> 被唤醒调度</li><li>调用 <code>gcDrain</code>，先扫所有根对象 <code>nDataRoots, nBSSRoots, nSpanRoots, nStackRoots</code>，然后循环调用 <code>scanobject</code> 标记工作队列里的对象；工作队列分为本地工作队列 <code>P.gcw</code> 和全局工作队列，标记过程中会对本地和全局工作队列进行平衡，比如本地队列满了，则会拿出一部分放到全局队列</li><li>检测到标记结束后，会调用 <code>gcMarkDone</code>，暂停世界，并调用 <code>gcMarkTermination -> gcSweep -> sweepone</code> 进行清扫，最后通过调用 <code>mheap.freeSpan(span)</code> 把空 <code>span</code> 放回堆里；<code>sweep</code> 结束后，唤醒 <code>scavenger</code>，把空余内存和不使用的页还给操作系统</li><li>启动世界，继续调度</li></ul><p>并发标记能够解决垃圾回收时暂停世界时间过长的问题，Go 的垃圾回收主要在清扫阶段暂停世界。标记任务通过本地队列、全局队列进行两级存储，本地队列无锁性能高，全局队列可以平衡不同协程之间的工作量。</p><h3 id=协程创建与调度><a href=#%e5%8d%8f%e7%a8%8b%e5%88%9b%e5%bb%ba%e4%b8%8e%e8%b0%83%e5%ba%a6 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>协程创建与调度</h3><p><code>go</code> 关键字会在编译时转换为对 <code>proc.go/newproc(fn)</code> 的调用，它会调用 <code>newproc1(fn, currentG, currentCallerPc)</code> 创建协程，并通过 <code>runqput(currentP, newg, true)</code> 加到运行队列：</p><ul><li><code>runqput</code> 第三个参数为 true 表示会把 <code>newg</code> 加到本地 <code>P</code> 的 <code>next slot</code>，也即本地 <code>P</code> 下次调度的 <code>G</code> 就是刚创建的 <code>newg</code>（如果过程中创建了新的 <code>G</code>，则又会被新的 <code>G</code> 抢占 <code>next slot</code>）</li><li><code>runqput</code> 先尝试把 <code>G</code> 加到容量为 256 的本地队列（无锁），如果本地队列已满，则把 <code>newg</code> 和本地队列的一半 <code>G</code> 放到全局队列</li></ul><p><code>newproc1</code> 创建协程的主要流程：</p><ul><li>调用 <code>gfget</code> 尝试从 <code>P</code> 本地 <code>freelist</code> 获取一个被回收的 <code>G</code>，本地如果没有，则从全局 <code>freelist</code> 获取 32 个 <code>G</code> 到本地；得到 <code>G</code> 后会判断是否有栈，没有的话会调用 <code>stackalloc</code> 申请栈空间</li><li>如果 <code>freelist</code> 没有可用 <code>G</code>，则调用 <code>malg</code> 创建新的 <code>G</code>，并申请栈空间</li><li>设置栈指针 <code>SP</code></li><li>设置 <code>sched.pc</code> 为 <code>goexit</code>，这样每个协程最后退出时都会执行 <code>goexit</code></li><li>设置 <code>startpc</code> 为用户协程函数 <code>fn</code></li><li>修改 <code>G</code> 的状态为 <code>_Grunnable</code></li></ul><p>触发调度的场景有很多，调度的最终入口都在 <code>proc.go/schedule()</code>。触发调度的情况有：</p><ul><li><strong>主动挂起</strong>：<code>gopark</code> -> <code>park_m</code>，状态修改为 <code>_Gwaiting</code>，通常发生在 <code>channel</code> 阻塞，等待 <code>time</code>、<code>netpoll</code> 等；<code>pack_m</code> 会把 <code>G-M</code> 解绑，并等待调用 <code>goready</code> 后，修改为 <code>_Grunnable</code> 并调用 <code>runqput</code> 加入到运行队列</li><li><strong>系统调用</strong>：<code>cgocall</code> -> <code>entersyscall/exitsyscall</code>，系统调用开始与退出。<code>entersyscall</code> 进入系统调用，保存 <code>SP/PC</code>，<code>M-P</code> 解绑并记录 <code>P</code> 为 <code>m.oldp</code>，状态修改为 <code>_Gsyscall</code>，P 的状态也为 <code>_Psyscall</code>；<code>exitsyscall</code> 已退出系统调用，状态修改为 <code>_Grunnable</code>，并把 <code>G</code> 加入到 <code>oldp</code> 运行队列</li><li><strong>协作式调度</strong>：<code>GC</code> 阶段，信号触发，以及用户程序都可以调用 <code>Gosched</code></li><li><strong>系统监控</strong>：<code>sysmon</code> -> <code>retake</code>，如果当前 <code>G</code> 已运行（或 <code>P</code> 陷入系统调用）超过 10ms，则调用 <code>preemptone</code> 通过信号 <code>sigPreempt</code> 发送抢占请求</li></ul><p><code>schedule</code> 先调用 <code>findRunable</code> 找到一个等待运行的 <code>G</code>，然后调用 <code>execute</code> 执行它。</p><p><code>findRunable</code> 查找一个可运行 <code>G</code> 的顺序：</p><ul><li>以 1/61 的概率从全局待运行队列里查找一个</li><li>从 <code>P</code> 的本地 <code>runq</code> 中查找</li><li>本地没有，则从全局 <code>runq</code> 中查找，并拿一部分 <code>G</code> 到本地</li><li>调用 <code>netpoll</code> 从网络轮询器中查找是否有就绪的 <code>G</code></li><li>从其他 <code>P</code> 中偷取</li><li>会再次尝试全局队列及网络轮询器</li><li>重复上述过程，直到找到一个就绪的 <code>G</code></li></ul><p><code>execute</code> 会把当前 <code>G-M</code> 解绑，把要运行的 <code>G</code> 与 <code>M</code> 绑定，最后调用 <code>gogo(&amp;g.sched)</code> 恢复 <code>G</code> 的执行上下文，并继续执行。</p><p>此流程里并没有把当前的 <code>G</code> 重新入待运行队列的操作，因为 P 的本地队列是一个 <code>[256]uintptr</code> 数组，以及两个指针 <code>head tail</code>，当前 <code>G</code> 本身就处于 <code>head</code> 和 <code>tail</code> 之间。<code>P</code> 中关于 <code>G</code> 的一些字段如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>p</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>//...
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>runqhead</span> <span class=kt>uint32</span>
</span></span><span class=line><span class=cl>	<span class=nx>runqtail</span> <span class=kt>uint32</span>
</span></span><span class=line><span class=cl>	<span class=nx>runq</span>     <span class=p>[</span><span class=mi>256</span><span class=p>]</span><span class=nx>guintptr</span>
</span></span><span class=line><span class=cl>	<span class=nx>runnext</span> <span class=nx>guintptr</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Available G&#39;s (status == Gdead)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>gFree</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>gList</span>
</span></span><span class=line><span class=cl>		<span class=nx>n</span> <span class=kt>int32</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Go 协程退出时会调用汇编程序里的 <code>goexit</code>，最终调用 <code>goexit0(g)</code> 来结束协程。它把 <code>G</code> 的状态设置为 <code>_Gdead</code>，并回收 <code>G</code> 的资源，最后触发调度。回收资源包括：</p><ul><li>把栈加入到 <code>GC</code> 扫描栈，用于释放栈引用的堆内存；</li><li>解绑 <code>M</code>；</li><li>如果栈空间大于初始的 2kB，回收整个栈；</li><li>把 <code>G</code> 加入到本地 <code>P.gFree</code>，如果 <code>P.gFree.number > 64</code>，则把一半的 <code>dead G</code> 加入到全局 <code>gFree</code></li></ul><h2 id=总结><a href=#%e6%80%bb%e7%bb%93 class=anchor><svg class="icon" aria-hidden="true" focusable="false" height="16" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5.0-3-1.69-3-3.5S2.55 3 4 3h4c1.45.0 3 1.69 3 3.5.0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98.0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98.0-2-1.22-2-2.5.0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45.0 3-1.69 3-3.5S14.5 6 13 6z"/></svg></a>总结</h2><p>Go 运行时初始化阶段进行了运行环境读取（操作系统内核数、页大小、环境变量、参数等）及一些初始化工作（各种内存分配器初始化、随机/hash 算法初始化，<code>P</code> 及应用程序的 init 函数）。</p><p>Go 的垃圾回收经过多个版本的迭代，已经非常成熟，通过在各个 P 上并发标记，大大减少了 STW 的时间。</p><p>运行时的设计充分体现了多级缓存的思想：堆、栈内存的分配设立了本地/全局缓存，堆对象的内存申请也很多对象大小进行分级，使用 <code>spanClass</code> 把对象进行分类，不仅加快分配速度，还减少了空间碎片；协程调度、协程创建与回收，也使用本地/全局缓存，降低锁争用的发生。这种多级缓存、按类分配的思想能给我们在做系统设计时提供启发。</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://cbsheng.github.io/posts/%E6%8E%A2%E7%B4%A2golang%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/>探索 golang 启动过程</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-stack-management/#%E6%A0%88%E6%89%A9%E5%AE%B9>draveness Go 语言设计与实现，栈扩容</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://geektutu.com/post/hpg-escape-analysis.html>极客兔兔 Go 语言高性能编程，内存逃逸</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C>draveness Go 语言设计与实现，混合写屏障</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></div><div class=container><nav class="flex container suggested"><a rel=prev href=/posts/raft-protocol/ title="Previous post (older)"><span>Previous</span>
Raft 协议核心内容</a>
<a rel=next href=/posts/coding-with-openai/ title="Next post (newer)"><span>Next</span>
使用 OpenAI 协作完成项目，好用到离不开</a></nav></div><div class=container><script src=https://giscus.app/client.js data-repo=xiang-xx/xiang-xx.github.io data-repo-id=R_kgDOI4YfdA data-category=Comment data-category-id=DIC_kwDOI4YfdM4CT7aL data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-theme=light crossorigin=anonymous async></script><script>function setGiscusTeheme(e){let t=document.querySelector(".giscus iframe");t&&t.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}addEventListener("message",e=>{if(e.origin!=="https://giscus.app")return;setGiscusTeheme(document.documentElement.dataset.userColorScheme)}),window.addEventListener("onColorSchemeChange",e=>{setGiscusTeheme(e.detail)})</script></div></main></main><footer class="footer flex"><section class=container><nav class=footer-links><a href=/index.xml>RSS</a></nav></section><script defer src=/ts/features.706a523ba43e6d0427c7fdf2b9d05dbd0920d3f12942b453690b495cb2522743.js data-enable-footnotes=true></script></footer></body></html>
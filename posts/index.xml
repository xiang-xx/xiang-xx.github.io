<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on XX Blog</title><link>https://xiang-xx.github.io/posts/</link><description>Recent content in Posts on XX Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 05 Mar 2023 09:28:11 +0800</lastBuildDate><atom:link href="https://xiang-xx.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang 运行时探究</title><link>https://xiang-xx.github.io/posts/go-runtime-explore/</link><pubDate>Sun, 05 Mar 2023 09:28:11 +0800</pubDate><guid>https://xiang-xx.github.io/posts/go-runtime-explore/</guid><description>版本与原型环境：Golang: 1.19.6; WSL2 Ubuntu-20.04
本文尽量不放过多源码，只注明源码位置及大致逻辑，开发者还需要自己阅读源码才能对 runtime 有更深刻的体会。runtime 代码都在 src/runtime 目录下。
启动阶段 Debug 运行一段最简单的代码，观察一下程序刚启动后的调用堆栈：
1 2 3 func main() { fmt.Println(&amp;#34;hello world&amp;#34;) // 程序停在这 } 观察程序的 Call Stack，可以发现启动了五个协程，根据调用栈可以找到这五个协程对应的入口:
runtime.main，它调用了我们定义的 main 函数，是用户程序的入口 runtime.forcegchelper，gc 辅助协程，它在 proc.go 的 runtime.init 中被调用 runtime.bgsweep，gc 标记，在 runtime.gcenable 中被启动 runtime.bgscavenge，gc 清除，也在 runtime.gcenable 中被启动；runtime.gcenable 在 runtime.main中被调用 runtime.runfinq，它是运行所有 finalizers 的协程，它只被启动一次，会在第一次调用 runtime.SetFinalizer 时被启动。用户自定义的所有 Finalizer 都会在这个写成立串行执行，所以要在 Finalizer 里执行耗时操作，最好启动新的协程。 以上只是在 go 的层面观察到的启动顺序。Go 程序启动的最初入口在汇编代码层面，主要是在 runtime.rt0_go 汇编函数中1：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 TEXT runtime·rt0_go(SB),NOSPLIT|TOPFRAME,$0 // .</description></item><item><title>Raft 协议核心内容</title><link>https://xiang-xx.github.io/posts/raft-protocol/</link><pubDate>Wed, 01 Mar 2023 19:26:36 +0800</pubDate><guid>https://xiang-xx.github.io/posts/raft-protocol/</guid><description>关于 raft Raft1 是一种共识算法，它能够使得系统成员部分失效后，系统仍然能够工作。本质上是一个备份状态机，它具有以下特性：
安全性：永远不会返回错误数据（尽管存在拜占庭故障、网络分区、延迟、丢包等） 高可用：只要大多数节点存活（互相之间能通讯，能被客户端访问到），系统就是可用的 共识日志不依赖时间（因为系统可能存在时间故障、严重延迟等） 一般情况下，只要集群大多数响应命令完成，则此命令就会完成，避免少量慢节点影响整体服务性能 Raft 部分思想受 Paxos、zab 等协议启发，但 Raft 协议简单很多：作者在论文中多次强调 Paxos 过于复杂，他们花了一年时间才真正搞懂 Paxos 究竟是如何工作的。而 Raft 协议的初衷就是创建一个更简单的共识算法，更简单意味着可以被更多人学习、理解，能更好的在生产中实现、使用。
这个网站2使用分步动画形式很好的解释了 raft 的运行方式，通过它可以对 raft 协议有大致的认识。
Raft 共识算法概要 Raft 算法要求先选出 leader，然后 leader 接收客户端的 log entries，复制给其他 servers，并告诉它们什么时候可以把 log entries 应用到它们的状态机。
Raft 协议把共识算法分解成三个互相无依赖的子问题：
Leader election：当现有的 leader 失效后，必须选举出新 leader Log replication：leader 从客户端接收 log entries，并复制到集群的其他 servers 上 Safety：如果一个 server 把某个 log entry 应用到它的状态机，则集群其他 server 与此 log entry 相同的 log index 上，使用的都是同一个 log entry. Raft 详细内容 所有服务器的持久状态（persistent state）： currentTerm: 服务器上次看到的 term votedFor: 当前 term 收到投票的服务器ID，如果没有，是 null log[]: log entries，从 leader 接收到的每个 entry 都包含状态机的命令，和当时的 term 所有服务器的不稳定状态 （volatile state）： commitIndex: 已知需要提交的最高 log 的 index lastApplied: 已经应用到状态机的最高 log 的 index leader 服务器的不稳定状态（选举后重新初始化） nextIndex[] 需要发送给特定 server 的下一个 entry 的 index（初始化为 leader last log index + 1） matchIndex[] 已知在每个 server 上已复制的 index AppendEntries Rpc leader 调用用来备份 entries；同时也是用来作为心跳的 rpc 参数：</description></item><item><title>读《设计数据密集型应用》</title><link>https://xiang-xx.github.io/posts/read-ddia/</link><pubDate>Sat, 25 Feb 2023 12:12:05 +0800</pubDate><guid>https://xiang-xx.github.io/posts/read-ddia/</guid><description>前言 互联网企业里或多或少都会有些数据密集型系统，比如一家互联网教育企业，付费用户虽然不多，但视频观看打点频率高，观看日志的数据量可以很大；一个在线聊天软件，用户聊天数据也会快速增长。《设计数据密集型应用》1一书内容丰富，涵盖了数据系统存储细节、分布式、数据一致性等问题，由浅入深，由底层细节到顶层架构，循序渐进地展开一张数据密集型系统的画卷全貌。
可靠性、可伸缩性和可维护性 与数据密集型系统对应的是计算密集型系统。在互联网行业中，更常见的是数据密集型系统。此书的目标是介绍如何打造可靠、可伸缩、可维护的数据系统。
可靠性：系统在困境中（硬件故障、软件故障、人为错误）仍可以正常工作 可伸缩性：有合理的办法应对系统的增长（数据量，流量，复杂性） 可维护性：许多不同的人，在不同的声明周期，都能高效的在系统上工作 提高可靠性：
硬件：提高冗余度 软件：彻底的测试、进程隔离、允许崩溃重启、测量/监控/自检/报警等 人为错误：沙箱环境、只读环境、允许快速回滚、允许数据重算、API 限制、管理后台、人员培训等（最小化犯错误机制，允许犯错并修复，监控错误产生） 性能：批处理关注吞吐量，在线服务系统关注响应时间。
通常使用响应时间的高位百分比描述服务性能。比如: 50%的响应小于200ms，99% 的响应时间小于 1s，即 p50&amp;lt;100ms, p99&amp;lt;1s。
可伸缩性：纵向伸缩（scaling up），横向伸缩（scaling out）。
可维护性与软件系统设计的原则：
可操作性：便于（运维团队）维护系统平稳运行 简单性：从系统中尽可能消除复杂度。减少系统状态、降低模块耦合、理清依赖关系、术语命名一致&amp;hellip; 可演化性（可扩展性，可塑性） 数据模型与查询语言 常见的数据模型：
网状模型（CODASQL 为例）：数据库存在模式；访问特定记录需要遍历其中一条路径；查询是命令式，难以编写和维护 关系型：写时模式（schema-on-write）；范式设计导致从数据到代码对象需要复杂的转化；能够更好的处理多对多的关系；查询时通常需要遍历更多的数据 文档型：读时模式（schema-on-read）；代码查询简单；文档引用技术解决多对多的关系；查询局部性相对好；更新文档通常需要整个重写。 图模型：更适合多对多的关系；顶点和边不仅限于一种类型，顶点可以表示人、地点、事件，边可以表示哪些人彼此是好友、谁参与了哪个事件；适用于社交图谱，网络图谱，公路铁路网络等。 其他：用于基因相似性检测的搜索引擎（序列相似性搜索）；全文搜索；PB级大数据存储模型。 声明式查询语言（SQL，mongo，es）：简单容易；隐藏了数据库细节，便于兼容前后版本；适合并行查询。
命令式查询语言（例如 CODASQL）：类似编程语言的执行逻辑。
MapReduce 介于声明式和命令式之间，使用代码逻辑编写，但能够并行在多台机器上分布式执行。
存储与检索 存储引擎的两个大类
日志结构（log-structured） 面向页面（page-oriented） 日志结构存储引擎通常是追加写，在机械硬盘上性能较好，崩溃恢复简单，日志文件分段，删除使用特殊的标记，段文件可以后台合并，单独一个写线程避免并发问题。
日志结构的散列索引：范围查询性能很低；必须能够放在内存里，否则磁盘映射性能很低。
SSTable 排序字符串表，LSM（日志文件合并树）：
每个段文件内 key 是有序的 多个段文件合并后按照 key 的顺序写入到新段文件 当前段文件使用有序结构（红黑树等）维护在内存中，磁盘维护当前分段的顺序写日志；达到一定阈值，写入新段文件，删除旧的顺序写日志 使用 bloom 过滤器，优化不存在的 key 的查找 有序 key 可以加快范围查询 面向页面结构的存储引擎通常使用 B 树及其变体作为存储引擎。 B 树将数据库分解成固定大小的块或页，一次性只能读取或写入一个页面；这种设计接近底层页面，因为磁盘空间也是按照固定大小组织的 页面之间使用地址（硬盘地址，而非内存地址）互相引用，构建出树 一个页面的引用数量称为分支因子，通常是几百（分支因子为 500 的 4KB 页面的四层树可以存储 256T 数据） 使用预写日志（WAL，或重做日志 redo log，追加写文件）实现崩溃恢复 使用锁控制页面写入 如果一个页满了，则分裂成两个半页 B 树相关优化：</description></item><item><title>读《计算机程序的构造和解释》</title><link>https://xiang-xx.github.io/posts/read-sicp/</link><pubDate>Sat, 04 Feb 2023 09:31:29 +0800</pubDate><guid>https://xiang-xx.github.io/posts/read-sicp/</guid><description>前言 《计算机程序的构造和解释》（Structure and Interpretation of Computer Programs、SICP）1，也称 SICP，是麻省理工学院（MIT）计算机科学的入门教材。书中以 Scheme 语言为例（Lisp - List Processing 语言的一种方言），通过大量代码案例，详细介绍了程序如何抽象构造出来，以及程序解释/编译/运行的基本流程。对于日常使用高级语言的工程师来说，阅读此书能够对程序底层运行过程有一定的理解。
编程语言的抽象 编程语言提供一些基础元素，比如基本类型，运算符，关键字等，并使用表达式构建成语句，语句通过一系列的方式构成 复合过程（函数，方法，闭包，lambda 等）。
一个问题的求解过程通常可以有很多种，比如计算阶乘，可以用简单的递归算法：
1 2 3 4 5 6 func factorial(n int) int { if n == 1 { return 1 } return n * factorial(n-1) } 此算法的计算过程：先展开，后归约，比如计算 factorial(4)，展开与规约的过程：
4 * f(3) 4 * 3 * f(2) 4 * 3 * 2 * f(1) 4 * 3 * 2 * 1 4 * 3 * 2 4 * 6 24 如果使用迭代的方式计算：</description></item></channel></rss>
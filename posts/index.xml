<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on XX Blog</title><link>https://xiang-xx.github.io/posts/</link><description>Recent content in Posts on XX Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 22 May 2023 20:19:19 +0800</lastBuildDate><atom:link href="https://xiang-xx.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>术语命名混乱问题及解决方案</title><link>https://xiang-xx.github.io/posts/name-confusion-lead-to-bugs/</link><pubDate>Mon, 22 May 2023 20:19:19 +0800</pubDate><guid>https://xiang-xx.github.io/posts/name-confusion-lead-to-bugs/</guid><description>前言 在日常开发中，当你看到代码里的 userId 变量时，你无需检查代码的上下文，就猜到它代表的是 user 表的主键 id。但有时候出于各种原因，导致变量实际代表的意义并非我们所想的那样，如果我们按照自己认为的那样进行编码，则可能造成严重问题。
我遇到的典型案例 1. 某教育公司的 teacher 表里有三个数字字段分别是：id，teacher_id，teacher_uid；其中，id 是自增主键，teacher_id 是发号器生成的全局唯一 id；teacher_uid 是绑定的用户 id。
当代码里、或其他表字段里出现一个 teacher_id 时，如果不查看上下文，你很难知道它代表的是 teacher 表的哪个字段。曾经就有一位研发在建表时使用 teacher_id 代表了 teacher_uid，导致某些功能查询 teacher 信息失败。
在设计表时，如果决定使用递增全局唯一 id 时，就没必要再保留主键自增了，把从发号器拿到的全局唯一 id 作为主键存储即可，这样就避免了 teacher_id 的语义问题。再规范使用 teacher_id 与 teacher_uid，则可以避免此类字段引起问题。
2. 某电子商务公司的支付系统的各个服务中，customer_id 经常用来表示企业用户 id，企业信息、账单、合规认证等各个系统表里及代码里都是用 customer_id 表示企业用户 id。
后来在开发一个数据统计功能时，某新人研发要根据订单概要表统计企业销售数据，代码逻辑是根据此表的 customer_id 进行聚合查询等操作。临上线时发现聚合得到的数据跟其他系统的数据对不上，后来调查发现此处的 customer_id 是消费者用户 id，并非企业 id。
同一系统中，同一个单词只能代表一种主体，必须确保术语的语义唯一。
3. 某互联网公司的系统中有如下三张表： swap_result(id, ...)， swap_record(id, ..., swap_result_id)，swap_extrinsic(id, ..., swap_result_id)。
后面两张表里都有相同数据类型的 swap_result_id。使用其中的 swap_result_id 去 swap_result 表中按主键查询，什么也查不到，就算有能查到的数据，但各种场景都对不上。后来翻代码才发现，swap_record.swap_result_id 是 swap_extrinsic.id，而 swap_extrinsic.</description></item><item><title>使用 OpenAI 协作完成项目，好用到离不开</title><link>https://xiang-xx.github.io/posts/coding-with-openai/</link><pubDate>Tue, 28 Mar 2023 10:08:48 +0800</pubDate><guid>https://xiang-xx.github.io/posts/coding-with-openai/</guid><description>需求案例 最近有个需求，使用 ChatGPT 的 Embedding 技术实现自定义 AI 助手。
总体功能：用户上传 pdf 或者其他知识库，程序把用户上传的知识库调用 ChatGPT 的 Embedding api 进行向量化并存储到向量数据库。用户跟自己创建的 AI 助手对话时，根据用户的问题匹配向量数据库的内容，把匹配到的内容作为上下文知识，调用 ChatGPT 的 Completions api 完成对话补全。
总体功能类似此项目：gpt4-pdf-chatbot-langchain
背景信息 ChatGPT 版本：ChatGPT-4
此项目要求使用 python 开发，基本的技术栈为：
web 框架：fastapi 核心库：langchain python 虚拟环境包管理工具：poetry 向量存储库：chromadb/redisvector/pinecone 我对 python 不太熟，几年前自己接触过一点，写了一些 demo。那时候连 virtual env 都很少用。所以为了快速上手，很多知识点都需要问 ChatGPT。
协作开发过程 在选择向量存储工具时，我让 ChatGPT 对三种备选方案进行对比，分析其优劣势。ChatGPT 给了比较准确的回复，它还给出了一个简短的总结：
总之，选择哪种技术取决于你的具体需求和应用场景。如果你需要一个简单的、轻量级的解决方案，Redis 可能足够了。然而，对于大规模的矢量搜索和相似度查询，Pinecone 可能是一个更好的选择。Chroma 可能适合某些特定需求，但可能需要更多的开发工作。
在使用 pinecone 时，对 index 的两个参数 dimensions 和 metrics 的作用不太清楚，也不知道如何设置。通过咨询 ChatGPT，能很快地得到答案（这里截取部分内容）：
Dimensions 指的是矢量的维度。在创建 Pinecone 索引时，需要指定矢量的维度。这个维度需要与您的矢量数据集的实际维度保持一致。矢量维度的选择取决于特征提取和表示方法。对于某些场景，较低的维度可能足以捕捉到数据的重要特征；而对于其他场景，较高的维度可能有助于提高搜索准确性。在实际应用中，可以通过实验和评估来确定合适的矢量维度。
Metrics 是用于度量矢量之间相似度的方法。Pinecone 支持多种相似度度量，如欧几里得距离（euclidean）、余弦相似度（cosine）和内积（dot-product）等。相似度度量的选择取决于您的应用场景和数据类型。例如，在处理文本数据时，余弦相似度通常是一个不错的选择；而在处理图像或其他连续数据时，欧几里得距离可能更合适。在实际应用中，可以通过实验和评估来确定合适的相似度度量。</description></item><item><title>Golang 运行时探究</title><link>https://xiang-xx.github.io/posts/go-runtime-explore/</link><pubDate>Sun, 05 Mar 2023 09:28:11 +0800</pubDate><guid>https://xiang-xx.github.io/posts/go-runtime-explore/</guid><description>版本与原型环境：Golang: 1.19.6; WSL2 Ubuntu-20.04
本文尽量不放过多源码，只注明源码位置及大致逻辑，开发者还需要自己阅读源码才能对 runtime 有更深刻的体会。runtime 代码都在 src/runtime 目录下。
启动阶段 Debug 运行一段最简单的代码，观察一下程序刚启动后的调用堆栈：
1 2 3 func main() { fmt.Println(&amp;#34;hello world&amp;#34;) // 程序停在这 } 观察程序的 Call Stack，可以发现启动了五个协程，根据调用栈可以找到这五个协程对应的入口:
runtime.main，它调用了我们定义的 main 函数，是用户程序的入口 runtime.forcegchelper，gc 辅助协程，它在 proc.go 的 runtime.init 中被调用 runtime.bgsweep，gc 标记，在 runtime.gcenable 中被启动 runtime.bgscavenge，gc 清除，也在 runtime.gcenable 中被启动；runtime.gcenable 在 runtime.main中被调用 runtime.runfinq，它是运行所有 finalizers 的协程，它只被启动一次，会在第一次调用 runtime.SetFinalizer 时被启动。用户自定义的所有 Finalizer 都会在这个写成立串行执行，所以要在 Finalizer 里执行耗时操作，最好启动新的协程。 以上只是在 go 的层面观察到的启动顺序。Go 程序启动的最初入口在汇编代码层面，主要是在 runtime.rt0_go 汇编函数中1：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 TEXT runtime·rt0_go(SB),NOSPLIT|TOPFRAME,$0 // .</description></item><item><title>Raft 协议核心内容</title><link>https://xiang-xx.github.io/posts/raft-protocol/</link><pubDate>Wed, 01 Mar 2023 19:26:36 +0800</pubDate><guid>https://xiang-xx.github.io/posts/raft-protocol/</guid><description>关于 raft Raft1 是一种共识算法，它能够使得系统成员部分失效后，系统仍然能够工作。本质上是一个备份状态机，它具有以下特性：
安全性：永远不会返回错误数据（尽管存在拜占庭故障、网络分区、延迟、丢包等） 高可用：只要大多数节点存活（互相之间能通讯，能被客户端访问到），系统就是可用的 共识日志不依赖时间（因为系统可能存在时间故障、严重延迟等） 一般情况下，只要集群大多数响应命令完成，则此命令就会完成，避免少量慢节点影响整体服务性能 Raft 部分思想受 Paxos、zab 等协议启发，但 Raft 协议简单很多：作者在论文中多次强调 Paxos 过于复杂，他们花了一年时间才真正搞懂 Paxos 究竟是如何工作的。而 Raft 协议的初衷就是创建一个更简单的共识算法，更简单意味着可以被更多人学习、理解，能更好的在生产中实现、使用。
这个网站2使用分步动画形式很好的解释了 raft 的运行方式，通过它可以对 raft 协议有大致的认识。
Raft 共识算法概要 Raft 算法要求先选出 leader，然后 leader 接收客户端的 log entries，复制给其他 servers，并告诉它们什么时候可以把 log entries 应用到它们的状态机。
Raft 协议把共识算法分解成三个互相无依赖的子问题：
Leader election：当现有的 leader 失效后，必须选举出新 leader Log replication：leader 从客户端接收 log entries，并复制到集群的其他 servers 上 Safety：如果一个 server 把某个 log entry 应用到它的状态机，则集群其他 server 与此 log entry 相同的 log index 上，使用的都是同一个 log entry. Raft 详细内容 所有服务器的持久状态（persistent state）： currentTerm: 服务器上次看到的 term votedFor: 当前 term 收到投票的服务器ID，如果没有，是 null log[]: log entries，从 leader 接收到的每个 entry 都包含状态机的命令，和当时的 term 所有服务器的不稳定状态 （volatile state）： commitIndex: 已知需要提交的最高 log 的 index lastApplied: 已经应用到状态机的最高 log 的 index leader 服务器的不稳定状态（选举后重新初始化） nextIndex[] 需要发送给特定 server 的下一个 entry 的 index（初始化为 leader last log index + 1） matchIndex[] 已知在每个 server 上已复制的 index AppendEntries Rpc leader 调用用来备份 entries；同时也是用来作为心跳的 rpc 参数：</description></item><item><title>读《设计数据密集型应用》</title><link>https://xiang-xx.github.io/posts/read-ddia/</link><pubDate>Sat, 25 Feb 2023 12:12:05 +0800</pubDate><guid>https://xiang-xx.github.io/posts/read-ddia/</guid><description>前言 互联网企业里或多或少都会有些数据密集型系统，比如一家互联网教育企业，付费用户虽然不多，但视频观看打点频率高，观看日志的数据量可以很大；一个在线聊天软件，用户聊天数据也会快速增长。《设计数据密集型应用》1一书内容丰富，涵盖了数据系统存储细节、分布式、数据一致性等问题，由浅入深，由底层细节到顶层架构，循序渐进地展开一张数据密集型系统的画卷全貌。
可靠性、可伸缩性和可维护性 与数据密集型系统对应的是计算密集型系统。在互联网行业中，更常见的是数据密集型系统。此书的目标是介绍如何打造可靠、可伸缩、可维护的数据系统。
可靠性：系统在困境中（硬件故障、软件故障、人为错误）仍可以正常工作 可伸缩性：有合理的办法应对系统的增长（数据量，流量，复杂性） 可维护性：许多不同的人，在不同的声明周期，都能高效的在系统上工作 提高可靠性：
硬件：提高冗余度 软件：彻底的测试、进程隔离、允许崩溃重启、测量/监控/自检/报警等 人为错误：沙箱环境、只读环境、允许快速回滚、允许数据重算、API 限制、管理后台、人员培训等（最小化犯错误机制，允许犯错并修复，监控错误产生） 性能：批处理关注吞吐量，在线服务系统关注响应时间。
通常使用响应时间的高位百分比描述服务性能。比如: 50%的响应小于200ms，99% 的响应时间小于 1s，即 p50&amp;lt;100ms, p99&amp;lt;1s。
可伸缩性：纵向伸缩（scaling up），横向伸缩（scaling out）。
可维护性与软件系统设计的原则：
可操作性：便于（运维团队）维护系统平稳运行 简单性：从系统中尽可能消除复杂度。减少系统状态、降低模块耦合、理清依赖关系、术语命名一致&amp;hellip; 可演化性（可扩展性，可塑性） 数据模型与查询语言 常见的数据模型：
网状模型（CODASQL 为例）：数据库存在模式；访问特定记录需要遍历其中一条路径；查询是命令式，难以编写和维护 关系型：写时模式（schema-on-write）；范式设计导致从数据到代码对象需要复杂的转化；能够更好的处理多对多的关系；查询时通常需要遍历更多的数据 文档型：读时模式（schema-on-read）；代码查询简单；文档引用技术解决多对多的关系；查询局部性相对好；更新文档通常需要整个重写。 图模型：更适合多对多的关系；顶点和边不仅限于一种类型，顶点可以表示人、地点、事件，边可以表示哪些人彼此是好友、谁参与了哪个事件；适用于社交图谱，网络图谱，公路铁路网络等。 其他：用于基因相似性检测的搜索引擎（序列相似性搜索）；全文搜索；PB级大数据存储模型。 声明式查询语言（SQL，mongo，es）：简单容易；隐藏了数据库细节，便于兼容前后版本；适合并行查询。
命令式查询语言（例如 CODASQL）：类似编程语言的执行逻辑。
MapReduce 介于声明式和命令式之间，使用代码逻辑编写，但能够并行在多台机器上分布式执行。
存储与检索 存储引擎的两个大类
日志结构（log-structured） 面向页面（page-oriented） 日志结构存储引擎通常是追加写，在机械硬盘上性能较好，崩溃恢复简单，日志文件分段，删除使用特殊的标记，段文件可以后台合并，单独一个写线程避免并发问题。
日志结构的散列索引：范围查询性能很低；必须能够放在内存里，否则磁盘映射性能很低。
SSTable 排序字符串表，LSM（日志文件合并树）：
每个段文件内 key 是有序的 多个段文件合并后按照 key 的顺序写入到新段文件 当前段文件使用有序结构（红黑树等）维护在内存中，磁盘维护当前分段的顺序写日志；达到一定阈值，写入新段文件，删除旧的顺序写日志 使用 bloom 过滤器，优化不存在的 key 的查找 有序 key 可以加快范围查询 面向页面结构的存储引擎通常使用 B 树及其变体作为存储引擎。 B 树将数据库分解成固定大小的块或页，一次性只能读取或写入一个页面；这种设计接近底层页面，因为磁盘空间也是按照固定大小组织的 页面之间使用地址（硬盘地址，而非内存地址）互相引用，构建出树 一个页面的引用数量称为分支因子，通常是几百（分支因子为 500 的 4KB 页面的四层树可以存储 256T 数据） 使用预写日志（WAL，或重做日志 redo log，追加写文件）实现崩溃恢复 使用锁控制页面写入 如果一个页满了，则分裂成两个半页 B 树相关优化：</description></item><item><title>读《计算机程序的构造和解释》</title><link>https://xiang-xx.github.io/posts/read-sicp/</link><pubDate>Sat, 04 Feb 2023 09:31:29 +0800</pubDate><guid>https://xiang-xx.github.io/posts/read-sicp/</guid><description>前言 《计算机程序的构造和解释》（Structure and Interpretation of Computer Programs、SICP）1，也称 SICP，是麻省理工学院（MIT）计算机科学的入门教材。书中以 Scheme 语言为例（Lisp - List Processing 语言的一种方言），通过大量代码案例，详细介绍了程序如何抽象构造出来，以及程序解释/编译/运行的基本流程。对于日常使用高级语言的工程师来说，阅读此书能够对程序底层运行过程有一定的理解。
编程语言的抽象 编程语言提供一些基础元素，比如基本类型，运算符，关键字等，并使用表达式构建成语句，语句通过一系列的方式构成 复合过程（函数，方法，闭包，lambda 等）。
一个问题的求解过程通常可以有很多种，比如计算阶乘，可以用简单的递归算法：
1 2 3 4 5 6 func factorial(n int) int { if n == 1 { return 1 } return n * factorial(n-1) } 此算法的计算过程：先展开，后归约，比如计算 factorial(4)，展开与规约的过程：
4 * f(3) 4 * 3 * f(2) 4 * 3 * 2 * f(1) 4 * 3 * 2 * 1 4 * 3 * 2 4 * 6 24 如果使用迭代的方式计算：</description></item></channel></rss>
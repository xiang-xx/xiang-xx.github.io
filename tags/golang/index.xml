<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on XX Blog</title><link>https://xiang-xx.github.io/tags/golang/</link><description>Recent content in golang on XX Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 05 Mar 2023 09:28:11 +0800</lastBuildDate><atom:link href="https://xiang-xx.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang 运行时探究</title><link>https://xiang-xx.github.io/posts/go-runtime-explore/</link><pubDate>Sun, 05 Mar 2023 09:28:11 +0800</pubDate><guid>https://xiang-xx.github.io/posts/go-runtime-explore/</guid><description>版本与原型环境：Golang: 1.19.6; WSL2 Ubuntu-20.04
本文尽量不放过多源码，只注明源码位置及大致逻辑，开发者还需要自己阅读源码才能对 runtime 有更深刻的体会。runtime 代码都在 src/runtime 目录下。
启动阶段 Debug 运行一段最简单的代码，观察一下程序刚启动后的调用堆栈：
1 2 3 func main() { fmt.Println(&amp;#34;hello world&amp;#34;) // 程序停在这 } 观察程序的 Call Stack，可以发现启动了五个协程，根据调用栈可以找到这五个协程对应的入口:
runtime.main，它调用了我们定义的 main 函数，是用户程序的入口 runtime.forcegchelper，gc 辅助协程，它在 proc.go 的 runtime.init 中被调用 runtime.bgsweep，gc 标记，在 runtime.gcenable 中被启动 runtime.bgscavenge，gc 清除，也在 runtime.gcenable 中被启动；runtime.gcenable 在 runtime.main中被调用 runtime.runfinq，它是运行所有 finalizers 的协程，它只被启动一次，会在第一次调用 runtime.SetFinalizer 时被启动。用户自定义的所有 Finalizer 都会在这个写成立串行执行，所以要在 Finalizer 里执行耗时操作，最好启动新的协程。 以上只是在 go 的层面观察到的启动顺序。Go 程序启动的最初入口在汇编代码层面，主要是在 runtime.rt0_go 汇编函数中1：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 TEXT runtime·rt0_go(SB),NOSPLIT|TOPFRAME,$0 // .</description></item></channel></rss>
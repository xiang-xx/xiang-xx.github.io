<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>阅读 on XX Blog</title><link>https://xiang-xx.github.io/tags/%E9%98%85%E8%AF%BB/</link><description>Recent content in 阅读 on XX Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 25 Feb 2023 12:12:05 +0800</lastBuildDate><atom:link href="https://xiang-xx.github.io/tags/%E9%98%85%E8%AF%BB/index.xml" rel="self" type="application/rss+xml"/><item><title>读《设计数据密集型应用》</title><link>https://xiang-xx.github.io/posts/read-ddia/</link><pubDate>Sat, 25 Feb 2023 12:12:05 +0800</pubDate><guid>https://xiang-xx.github.io/posts/read-ddia/</guid><description>前言 互联网企业里或多或少都会有些数据密集型系统，比如一家互联网教育企业，付费用户虽然不多，但视频观看打点频率高，观看日志的数据量可以很大；一个在线聊天软件，用户聊天数据也会快速增长。《设计数据密集型应用》1一书内容丰富，涵盖了数据系统存储细节、分布式、数据一致性等问题，由浅入深，由底层细节到顶层架构，循序渐进地展开一张数据密集型系统的画卷全貌。
可靠性、可伸缩性和可维护性 与数据密集型系统对应的是计算密集型系统。在互联网行业中，更常见的是数据密集型系统。此书的目标是介绍如何打造可靠、可伸缩、可维护的数据系统。
可靠性：系统在困境中（硬件故障、软件故障、人为错误）仍可以正常工作 可伸缩性：有合理的办法应对系统的增长（数据量，流量，复杂性） 可维护性：许多不同的人，在不同的声明周期，都能高效的在系统上工作 提高可靠性：
硬件：提高冗余度 软件：彻底的测试、进程隔离、允许崩溃重启、测量/监控/自检/报警等 人为错误：沙箱环境、只读环境、允许快速回滚、允许数据重算、API 限制、管理后台、人员培训等（最小化犯错误机制，允许犯错并修复，监控错误产生） 性能：批处理关注吞吐量，在线服务系统关注响应时间。
通常使用响应时间的高位百分比描述服务性能。比如: 50%的响应小于200ms，99% 的响应时间小于 1s，即 p50&amp;lt;100ms, p99&amp;lt;1s。
可伸缩性：纵向伸缩（scaling up），横向伸缩（scaling out）。
可维护性与软件系统设计的原则：
可操作性：便于（运维团队）维护系统平稳运行 简单性：从系统中尽可能消除复杂度。减少系统状态、降低模块耦合、理清依赖关系、术语命名一致&amp;hellip; 可演化性（可扩展性，可塑性） 数据模型与查询语言 常见的数据模型：
网状模型（CODASQL 为例）：数据库存在模式；访问特定记录需要遍历其中一条路径；查询是命令式，难以编写和维护 关系型：写时模式（schema-on-write）；范式设计导致从数据到代码对象需要复杂的转化；能够更好的处理多对多的关系；查询时通常需要遍历更多的数据 文档型：读时模式（schema-on-read）；代码查询简单；文档引用技术解决多对多的关系；查询局部性相对好；更新文档通常需要整个重写。 图模型：更适合多对多的关系；顶点和边不仅限于一种类型，顶点可以表示人、地点、事件，边可以表示哪些人彼此是好友、谁参与了哪个事件；适用于社交图谱，网络图谱，公路铁路网络等。 其他：用于基因相似性检测的搜索引擎（序列相似性搜索）；全文搜索；PB级大数据存储模型。 声明式查询语言（SQL，mongo，es）：简单容易；隐藏了数据库细节，便于兼容前后版本；适合并行查询。
命令式查询语言（例如 CODASQL）：类似编程语言的执行逻辑。
MapReduce 介于声明式和命令式之间，使用代码逻辑编写，但能够并行在多台机器上分布式执行。
存储与检索 存储引擎的两个大类
日志结构（log-structured） 面向页面（page-oriented） 日志结构存储引擎通常是追加写，在机械硬盘上性能较好，崩溃恢复简单，日志文件分段，删除使用特殊的标记，段文件可以后台合并，单独一个写线程避免并发问题。
日志结构的散列索引：范围查询性能很低；必须能够放在内存里，否则磁盘映射性能很低。
SSTable 排序字符串表，LSM（日志文件合并树）：
每个段文件内 key 是有序的 多个段文件合并后按照 key 的顺序写入到新段文件 当前段文件使用有序结构（红黑树等）维护在内存中，磁盘维护当前分段的顺序写日志；达到一定阈值，写入新段文件，删除旧的顺序写日志 使用 bloom 过滤器，优化不存在的 key 的查找 有序 key 可以加快范围查询 面向页面结构的存储引擎通常使用 B 树及其变体作为存储引擎。 B 树将数据库分解成固定大小的块或页，一次性只能读取或写入一个页面；这种设计接近底层页面，因为磁盘空间也是按照固定大小组织的 页面之间使用地址（硬盘地址，而非内存地址）互相引用，构建出树 一个页面的引用数量称为分支因子，通常是几百（分支因子为 500 的 4KB 页面的四层树可以存储 256T 数据） 使用预写日志（WAL，或重做日志 redo log，追加写文件）实现崩溃恢复 使用锁控制页面写入 如果一个页满了，则分裂成两个半页 B 树相关优化：</description></item><item><title>读《计算机程序的构造和解释》</title><link>https://xiang-xx.github.io/posts/read-sicp/</link><pubDate>Sat, 04 Feb 2023 09:31:29 +0800</pubDate><guid>https://xiang-xx.github.io/posts/read-sicp/</guid><description>前言 《计算机程序的构造和解释》（Structure and Interpretation of Computer Programs、SICP）1，也称 SICP，是麻省理工学院（MIT）计算机科学的入门教材。书中以 Scheme 语言为例（Lisp - List Processing 语言的一种方言），通过大量代码案例，详细介绍了程序如何抽象构造出来，以及程序解释/编译/运行的基本流程。对于日常使用高级语言的工程师来说，阅读此书能够对程序底层运行过程有一定的理解。
编程语言的抽象 编程语言提供一些基础元素，比如基本类型，运算符，关键字等，并使用表达式构建成语句，语句通过一系列的方式构成 复合过程（函数，方法，闭包，lambda 等）。
一个问题的求解过程通常可以有很多种，比如计算阶乘，可以用简单的递归算法：
1 2 3 4 5 6 func factorial(n int) int { if n == 1 { return 1 } return n * factorial(n-1) } 此算法的计算过程：先展开，后归约，比如计算 factorial(4)，展开与规约的过程：
4 * f(3) 4 * 3 * f(2) 4 * 3 * 2 * f(1) 4 * 3 * 2 * 1 4 * 3 * 2 4 * 6 24 如果使用迭代的方式计算：</description></item></channel></rss>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>XX Blog</title><link>https://xiang-xx.github.io/</link><description>Recent content on XX Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 05 Mar 2023 09:28:11 +0800</lastBuildDate><atom:link href="https://xiang-xx.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang 运行时探究</title><link>https://xiang-xx.github.io/posts/go-runtime-explore/</link><pubDate>Sun, 05 Mar 2023 09:28:11 +0800</pubDate><guid>https://xiang-xx.github.io/posts/go-runtime-explore/</guid><description>
&lt;blockquote>
&lt;p>版本与原型环境：Golang: 1.19.6; WSL2 Ubuntu-20.04&lt;/p>
&lt;/blockquote>
&lt;p>本文尽量不放过多源码，只注明源码位置及大致逻辑，开发者还需要自己阅读源码才能对 runtime 有更深刻的体会。runtime 代码都在 &lt;a href="https://github.com/golang/go/tree/master/src/runtime">src/runtime&lt;/a> 目录下。&lt;/p>
&lt;h2 id="启动阶段">
&lt;a href="#%e5%90%af%e5%8a%a8%e9%98%b6%e6%ae%b5" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
启动阶段
&lt;/h2>
&lt;p>Debug 运行一段最简单的代码，观察一下程序刚启动后的调用堆栈：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;hello world&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 程序停在这
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>观察程序的 Call Stack，可以发现启动了五个协程，根据调用栈可以找到这五个协程对应的入口:&lt;/p>
&lt;ul>
&lt;li>&lt;code>runtime.main&lt;/code>，它调用了我们定义的 main 函数，是用户程序的入口&lt;/li>
&lt;li>&lt;code>runtime.forcegchelper&lt;/code>，gc 辅助协程，它在 proc.go 的 &lt;code>runtime.init&lt;/code> 中被调用&lt;/li>
&lt;li>&lt;code>runtime.bgsweep&lt;/code>，gc 标记，在 &lt;code>runtime.gcenable&lt;/code> 中被启动&lt;/li>
&lt;li>&lt;code>runtime.bgscavenge&lt;/code>，gc 清除，也在 &lt;code>runtime.gcenable&lt;/code> 中被启动；&lt;code>runtime.gcenable&lt;/code> 在 &lt;code>runtime.main&lt;/code>中被调用&lt;/li>
&lt;li>&lt;code>runtime.runfinq&lt;/code>，它是运行所有 &lt;code>finalizers&lt;/code> 的协程，它只被启动一次，会在第一次调用 &lt;code>runtime.SetFinalizer&lt;/code> 时被启动。用户自定义的所有 Finalizer 都会在这个写成立串行执行，所以要在 Finalizer 里执行耗时操作，最好启动新的协程。&lt;/li>
&lt;/ul>
&lt;p>以上只是在 go 的层面观察到的启动顺序。Go 程序启动的最初入口在汇编代码层面，主要是在 &lt;code>runtime.rt0_go&lt;/code> 汇编函数中&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-s" data-lang="s">&lt;span class="line">&lt;span class="cl">&lt;span class="n">TEXT&lt;/span> &lt;span class="n">runtime&lt;/span>·&lt;span class="nf">rt0_go&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SB&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="n">NOSPLIT&lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="n">TOPFRAME&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">$&lt;/span>&lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">//&lt;/span> &lt;span class="kc">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">nocgo&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">//&lt;/span> 创建 &lt;span class="n">m0&lt;/span> 和 &lt;span class="n">g0&lt;/span> 并相互引用
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">//&lt;/span> &lt;span class="n">save&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">g0&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">g0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">MOVD&lt;/span> &lt;span class="n">g&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nf">m_g0&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">R0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">//&lt;/span> &lt;span class="n">save&lt;/span> &lt;span class="n">m0&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="n">g0&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">m&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">MOVD&lt;/span> &lt;span class="n">R0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nf">g_m&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">g&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">//&lt;/span> 初始化：执行文件路径，内存页大小
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">BL&lt;/span> &lt;span class="n">runtime&lt;/span>·&lt;span class="nf">args&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SB&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">//&lt;/span> &lt;span class="n">runtime1.go&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">args&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">//&lt;/span> &lt;span class="n">CPU&lt;/span> 个数，大页内存页大小
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">BL&lt;/span> &lt;span class="n">runtime&lt;/span>·&lt;span class="nf">osinit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SB&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">//&lt;/span> &lt;span class="n">os_linux.go&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">osinit&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">//&lt;/span> 命令行参数、环境变量、&lt;span class="n">gc&lt;/span>、栈空间、内存管理、所有&lt;span class="n">P&lt;/span>实例、&lt;span class="n">HASH&lt;/span>算法等
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">BL&lt;/span> &lt;span class="n">runtime&lt;/span>·&lt;span class="nf">schedinit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SB&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">//&lt;/span> &lt;span class="n">proc.go&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">schedinit&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">//&lt;/span> &lt;span class="n">create&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="n">new&lt;/span> &lt;span class="n">goroutine&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="n">start&lt;/span> &lt;span class="n">program&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">//&lt;/span> 创建一个新的 &lt;span class="n">goroutine&lt;/span>，绑定 &lt;span class="n">runtime.main&lt;/span>，放在 &lt;span class="n">P&lt;/span> 本地队列，等待调度
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">MOVD&lt;/span> &lt;span class="o">$&lt;/span>&lt;span class="n">runtime&lt;/span>·&lt;span class="nf">mainPC&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SB&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">R0&lt;/span> &lt;span class="o">//&lt;/span> &lt;span class="n">entry&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">SUB&lt;/span> &lt;span class="o">$&lt;/span>&lt;span class="m">16&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">RSP&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">MOVD&lt;/span> &lt;span class="n">R0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">8&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">RSP&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">//&lt;/span> &lt;span class="n">arg&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">MOVD&lt;/span> &lt;span class="o">$&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">0&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">RSP&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">//&lt;/span> &lt;span class="n">dummy&lt;/span> &lt;span class="n">LR&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">BL&lt;/span> &lt;span class="n">runtime&lt;/span>·&lt;span class="nf">newproc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SB&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ADD&lt;/span> &lt;span class="o">$&lt;/span>&lt;span class="m">16&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">RSP&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">//&lt;/span> 启动 &lt;span class="n">M&lt;/span>，开始调度 &lt;span class="n">goroutine&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">BL&lt;/span> &lt;span class="n">runtime&lt;/span>·&lt;span class="nf">mstart&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SB&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>初始化过程做了很多事情，包括对于 android、ios 以及其他窗口应用的一些前置逻辑。用 &lt;code>schedinit&lt;/code> 函数的注释说，启动顺序是：&lt;/p>
&lt;ul>
&lt;li>call osinit&lt;/li>
&lt;li>call schedinit&lt;/li>
&lt;li>make &amp;amp; queue new G, The new G calls runtime·main.&lt;/li>
&lt;li>call runtime.mstart&lt;/li>
&lt;/ul>
&lt;p>我们主要关注 &lt;code>schedinit&lt;/code> 和 &lt;code>runtime.main&lt;/code>。&lt;/p>
&lt;p>&lt;code>schedinit&lt;/code> 的几个主要的初始化动作：&lt;/p>
&lt;ul>
&lt;li>初始化系统全局锁的 lock rank：系统层面的锁有很多，有些操作需要获取多个锁，对锁按照 rank 排序，防止死锁。&lt;/li>
&lt;li>设置 &lt;code>sched.maxmcount = 10000&lt;/code>，即 &lt;code>G-M-P&lt;/code> 模型中 &lt;code>M&lt;/code> 的最大数量（超出时会 panic）&lt;/li>
&lt;li>&lt;code>mallocinit&lt;/code>，包含若干内存管理过程
&lt;ul>
&lt;li>&lt;code>mheap_.init()&lt;/code> 用于初始化 &lt;code>span&lt;/code> 分配器、&lt;code>cache&lt;/code> 分配器及其他特殊分配器，以及初始化 136 个对应 &lt;code>spanClass&lt;/code> 的中央缓存 &lt;code>mheap.central[136]&lt;/code>，最后是向操作系统申请内存；这些内存分配器都是 &lt;code>fixalloc&lt;/code> 的实例，&lt;code>fixalloc&lt;/code> 用于固定大小对象的空闲列表分配器。&lt;/li>
&lt;li>使用 &lt;code>cache&lt;/code> 分配器初始化 &lt;code>mcache0&lt;/code>，用于初始化时候分配内存，后续会绑定到第一个 &lt;code>P&lt;/code>&lt;/li>
&lt;li>初始化 &lt;code>mheap_.arenaHints&lt;/code>，用于设置申请更多 &lt;code>heap areanas&lt;/code> 后的地址（go runtime 定义的内存地址）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>cpuinit&lt;/code> 读取 &lt;code>GODEBUG&lt;/code> 环境变量并初始化 cpu 信息&lt;/li>
&lt;li>&lt;code>alginit&lt;/code> 随机初始化 &lt;code>hash&lt;/code> 算法种子&lt;/li>
&lt;li>&lt;code>fastrandinit&lt;/code> 初始化随机算法种子&lt;/li>
&lt;li>&lt;code>modulesinit&lt;/code> 从所有加载的 &lt;code>module&lt;/code> 中创建 &lt;code>activeModules&lt;/code> 切片&lt;/li>
&lt;li>&lt;code>typelinksinit&lt;/code> 加载 &lt;code>activeModules&lt;/code> 定义的类型&lt;/li>
&lt;li>&lt;code>goargs&lt;/code> 初始化命令行 &lt;code>args&lt;/code>&lt;/li>
&lt;li>&lt;code>goenv&lt;/code> 初始化 &lt;code>env&lt;/code>&lt;/li>
&lt;li>&lt;code>gcinit&lt;/code> 初始化 &lt;code>gc work&lt;/code> 状态，以及对应锁的 &lt;code>rank&lt;/code>&lt;/li>
&lt;li>&lt;code>procresize&lt;/code> 设置 &lt;code>P&lt;/code> 的数量，创建 &lt;code>P&lt;/code> 并初始化 &lt;code>P&lt;/code>（如果 &lt;code>P&lt;/code> 数量变少，则销毁对应数量的 &lt;code>P&lt;/code>），第一个创建的 &lt;code>P&lt;/code> 的 &lt;code>P.mcache = mcache0&lt;/code>，后续的 &lt;code>P.mcache = allocmcache()&lt;/code>，即从 &lt;code>mheap&lt;/code> 中申请新的 &lt;code>mcache&lt;/code>；给当前 &lt;code>g.m&lt;/code> 绑定一个 P；&lt;code>mcache0 = nil&lt;/code> 全局 &lt;code>mcache0&lt;/code> 不再持有该内存指针；&lt;code>p.m.set(mget())&lt;/code> 尝试给 &lt;code>P&lt;/code> 绑定一个 &lt;code>M&lt;/code>；&lt;/li>
&lt;li>&lt;code>worldStarted&lt;/code> &lt;code>P&lt;/code> 可以运行了&lt;/li>
&lt;/ul>
&lt;p>&lt;code>runtime.main&lt;/code> 的主要流程：&lt;/p>
&lt;ul>
&lt;li>设置最大栈空间大小：64 位系统 1GB，32 位系统 250M，&lt;/li>
&lt;li>创建 &lt;code>sysmon&lt;/code> 线程，辅助垃圾清扫，协程调度&lt;/li>
&lt;li>&lt;code>doInit(runtime_inittask)&lt;/code> 调用 &lt;code>runtime init&lt;/code> 函数&lt;/li>
&lt;li>&lt;code>gcenable&lt;/code> 启动 gc 协程 &lt;code>bgsweep&lt;/code> &lt;code>bgscavenge&lt;/code>&lt;/li>
&lt;li>&lt;code>doInit(main_inittask)&lt;/code> 调用用户程序 &lt;code>init&lt;/code> 函数&lt;/li>
&lt;li>&lt;code>fn := main_main; fn()&lt;/code> 调用 &lt;code>main&lt;/code> 函数&lt;/li>
&lt;li>&lt;code>main&lt;/code> 函数返回后，函数退出&lt;/li>
&lt;/ul>
&lt;p>总的来说，初始化阶段可以分为两部分，第一部分是系统环境初始化：系统锁顺序、内存分配器、堆内存、最初的 &lt;code>mcache0&lt;/code>、&lt;code>hash&lt;/code> 与 随机算法、环境参数、&lt;code>process&lt;/code> 等，第二部分是运行环境初始化：运行环境所需的 &lt;code>sysmon&lt;/code> 线程（不绑定 &lt;code>P&lt;/code>，不在 &lt;code>G-M-P&lt;/code> 模型内调度）、垃圾标记与清扫协程、&lt;code>runtime&lt;/code> 与用户程序的 &lt;code>init&lt;/code>，以及最后启动 &lt;code>main&lt;/code> 函数。&lt;/p>
&lt;h2 id="运行阶段">
&lt;a href="#%e8%bf%90%e8%a1%8c%e9%98%b6%e6%ae%b5" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
运行阶段
&lt;/h2>
&lt;h3 id="内存模型">
&lt;a href="#%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
内存模型
&lt;/h3>
&lt;p>Go 使用 &lt;code>mheap&lt;/code> 管理所有堆内存。向操作系统申请的最小内存单元是 &lt;code>page&lt;/code>，go 程序每次向操作系统申请若干 &lt;code>page&lt;/code>，并使用 &lt;code>heapArena&lt;/code> 管理 &lt;code>mheap&lt;/code> 中 &lt;code>page&lt;/code> 的状态。从 &lt;code>mheap&lt;/code> 中申请内存的最小单位是 &lt;code>mspan&lt;/code>，它由若干 &lt;code>page&lt;/code> 组成。&lt;/p>
&lt;p>&lt;code>mspan&lt;/code> 根据存储的单个 &lt;code>object&lt;/code> 的内存大小划分为不同的 &lt;code>spanClass&lt;/code>，比如有的用于存储小对象，有的用于储存较大的对象；这种划分划分方式既能提高可用内存的查找效率，又能提高空间利用率，避免过多空间碎片。&lt;/p>
&lt;p>每个 &lt;code>mspan&lt;/code> 都在一个双向链表中，可能是 &lt;code>mheap&lt;/code> 的 &lt;code>busy list&lt;/code>，或者是某个 &lt;code>mcentral&lt;/code> 的 &lt;code>span list&lt;/code>。&lt;/p>
&lt;p>一些关键对象字段：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">mheap&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">pages&lt;/span> &lt;span class="nx">pageAlloc&lt;/span> &lt;span class="c1">// page allocation data structure
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">allspans&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">mspan&lt;/span> &lt;span class="c1">// all spans out there
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">arenas&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="nx">arenaL1Bits&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="nx">arenaL2Bits&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">heapArena&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 中心缓存
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">central&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nx">numSpanClasses&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">mcentral&lt;/span> &lt;span class="nx">mcentral&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">pad&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="nx">cpu&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">CacheLinePadSize&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="nx">unsafe&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">mcentral&lt;/span>&lt;span class="p">{})&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="nx">cpu&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">CacheLinePadSize&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">byte&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">mcentral&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">spanclass&lt;/span> &lt;span class="nx">spanClass&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">partial&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="nx">spanSet&lt;/span> &lt;span class="c1">// list of spans with a free object
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">full&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="nx">spanSet&lt;/span> &lt;span class="c1">// list of spans with no free objects
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">var&lt;/span> &lt;span class="nx">mheap_&lt;/span> &lt;span class="nx">mheap&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">mspan&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">next&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">mspan&lt;/span> &lt;span class="c1">// next span in list, or nil if none
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">prev&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">mspan&lt;/span> &lt;span class="c1">// previous span in list, or nil if none
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">list&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">mSpanList&lt;/span> &lt;span class="c1">// For debugging. TODO: Remove.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">startAddr&lt;/span> &lt;span class="kt">uintptr&lt;/span> &lt;span class="c1">// address of first byte of span aka s.base()
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">npages&lt;/span> &lt;span class="kt">uintptr&lt;/span> &lt;span class="c1">// number of pages in span
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">freeindex&lt;/span> &lt;span class="kt">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">nelems&lt;/span> &lt;span class="kt">uintptr&lt;/span> &lt;span class="c1">// number of object in the span.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="栈空间管理">
&lt;a href="#%e6%a0%88%e7%a9%ba%e9%97%b4%e7%ae%a1%e7%90%86" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
栈空间管理
&lt;/h3>
&lt;p>每个 &lt;code>G&lt;/code> 有自己的栈空间。调用 &lt;code>proc.go/newproc()&lt;/code> 创建新的协程，程序会尝试从本地 &lt;code>P.gFree&lt;/code> 和全局 &lt;code>sched.gFree&lt;/code> 获取一个 &lt;code>dead G&lt;/code>（被回收的 &lt;code>G&lt;/code>），则直接复用它的栈。如果没有 &lt;code>dead G&lt;/code>，则调用 &lt;code>malg(stackMin)&lt;/code> 创建一个拥有最小栈空间 2048 的 &lt;code>G&lt;/code>。&lt;/p>
&lt;p>编译器会为函数调用插入 &lt;code>runtime.morestack&lt;/code> 检查，如果栈空间不足，需要扩容&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>，则会调用 &lt;code>runtime.newstack&lt;/code> 扩容。&lt;code>newsize := oldsize * 2&lt;/code>，每次容量增加一倍；程序会检查 &lt;code>newsize&lt;/code> 是否符合新栈空间要求，如果不够，继续增大 &lt;code>newsize&lt;/code>。调用 &lt;code>copystack(gp *g, newsize uintptr)&lt;/code> 申请新的栈空间，并复制栈内容，把新栈指针设置到 &lt;code>g&lt;/code>，&lt;code>stackfree(old)&lt;/code> 回收旧栈。&lt;/p>
&lt;p>&lt;code>stack.go/stackalloc(n uint32)&lt;/code> 用于申请新的栈内存，主要逻辑为：&lt;/p>
&lt;ul>
&lt;li>如果 GODEBUG 设置 efence != 0，或 stackFromSystem !=0，则直接从系统内存中申请一段内存&lt;/li>
&lt;li>如果 n 小于 &lt;code>_StackCacheSize = 32768&lt;/code>，且小于 &lt;code>_FixedStack&amp;lt;&amp;lt;_NumStackOrders&lt;/code>（随系统变化），则尝试从本地或去全局 &lt;code>stack&lt;/code> 缓存获取：
&lt;ul>
&lt;li>如果当前 g.m 没有 p，或 p 不使用 &lt;code>stackcache&lt;/code>，则调用 &lt;code>stackpoolalloc&lt;/code> 从全局 &lt;code>stackpool&lt;/code> 中获取，&lt;code>stackpool&lt;/code> 没有可用缓存时，调用 &lt;code>mheap._allocManual&lt;/code> 从 &lt;code>mheap&lt;/code> 中申请。&lt;/li>
&lt;li>否则，从当前 P 的 &lt;code>mcache.stackcache&lt;/code> 申请，如果 &lt;code>mcache.stackcache&lt;/code> 为空，则调用 &lt;code>stackpoolalloc&lt;/code> 从全局 &lt;code>stackpool&lt;/code> 获取，直到 &lt;code>mcache.stackcache&lt;/code> 填充一半（&lt;code>size &amp;gt;= _StackCacheSize/2&lt;/code>）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>先尝试从全局 &lt;code>stackLarge&lt;/code> 缓存中获取，如果没有，则直接从 mheap 中调用 &lt;code>mheap_.allocManual&lt;/code> 申请包含若干 &lt;code>page&lt;/code> 的 &lt;code>span&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>在 gc 扫描栈的过程中，可能发生栈缩容，栈缩容与扩容类似，计算目标栈空间大小，调用 &lt;code>copystack(gp *g, newsize uintptr)&lt;/code> 申请新的栈空间，并复制栈内容，把新栈指针设置到 g，&lt;code>stackfree(old)&lt;/code> 回收旧栈。&lt;/p>
&lt;p>&lt;code>stackfree&lt;/code> 的逻辑与 &lt;code>stackalloc&lt;/code> 类似：&lt;/p>
&lt;ul>
&lt;li>若 n 小于 &lt;code>_StackCacheSize = 32768&lt;/code>，且小于 &lt;code>_FixedStack&amp;lt;&amp;lt;_NumStackOrders&lt;/code>，则尝试回收到全局 &lt;code>stackpool&lt;/code> 或者 &lt;code>p.mcache.stackcache&lt;/code>，回收过程也会根据各级缓存是否已满，则回收到上级缓存，直到最后回收到 &lt;code>mheap&lt;/code>
&lt;ul>
&lt;li>只有在 &lt;code>_GCoff&lt;/code> 阶段才能向 &lt;code>mheap&lt;/code> 直接回收栈空间&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>若 n 比较大，则根据 GC 阶段判断回收到哪里：
&lt;ul>
&lt;li>&lt;code>gcphase == _GCoff&lt;/code>：GC 没有运行，后台清扫中，没有开启写屏障，则直接回收到 &lt;code>mheap&lt;/code>&lt;/li>
&lt;li>GC 运行时，为了避免 &lt;code>span&lt;/code> 回收到 &lt;code>mheap&lt;/code> 后，又被申请用作堆 &lt;code>span&lt;/code>，可能与 gc 发生冲突，所以直接回收到 &lt;code>stackLarge&lt;/code> 缓存。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>总结一下，较小的栈存在两级缓存：本地 &lt;code>P&lt;/code> 缓存 &lt;code>P.mcache.stackcache&lt;/code>、全局 &lt;code>stackpool&lt;/code>；大的栈空间存在一级缓存：&lt;code>stackLarge&lt;/code>；申请缓存时根据条件分别尝试从各级缓存中申请，从全局或 mheap 申请/释放时否需要加锁，所以会优先尝试本地 &lt;code>P.mcache.stackcache&lt;/code>。释放缓存时，避免在 GC 时，栈 &lt;code>span&lt;/code> 回收到 &lt;code>mheap&lt;/code> 后又被申请为堆 &lt;code>span&lt;/code>，导致状态冲突，所以 GC 时不能向 &lt;code>mheap&lt;/code> 回收栈内存，最多只回收到全局栈缓存。&lt;/p>
&lt;p>此外，各级缓存都会根据栈空间大小（扩容次数），或栈的 &lt;code>page&lt;/code> 数量（large stack），划分为不同的链表（例如类型为：&lt;code>stackcache[size or page count] stackfreelist&lt;/code>）进行管理，方便快速找到对应大小的占空间。&lt;/p>
&lt;h3 id="堆内存申请">
&lt;a href="#%e5%a0%86%e5%86%85%e5%ad%98%e7%94%b3%e8%af%b7" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
堆内存申请
&lt;/h3>
&lt;p>以下情况，对象的内存会被分配到堆上 &lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>：&lt;/p>
&lt;ul>
&lt;li>内存原因：&lt;code>interface{}&lt;/code> 动态类型，编译期无法知道内存大小；栈空间不足，比如创建一个超过系统栈空间大小的数组&lt;/li>
&lt;li>作用域原因：闭包或协程访问外部作用域；函数内创建的指针返回到外部；指针被堆上的对象引用&lt;/li>
&lt;/ul>
&lt;p>堆内存申请的入口在 &lt;code>malloc.go/mallocgc(size uintptr, typ *_type, needzero bool)&lt;/code>，根据此函数注释可以了解到：&lt;/p>
&lt;ul>
&lt;li>小对象从本地 &lt;code>P&lt;/code> 的缓存中申请&lt;/li>
&lt;li>大对象（&amp;gt; 32kB）直接从 &lt;code>mheap&lt;/code> 中申请&lt;/li>
&lt;/ul>
&lt;p>内存申请的主要逻辑为：&lt;/p>
&lt;ul>
&lt;li>如果申请内存大小 &lt;code>size&lt;/code> 为 0，则直接返回一个固定的 &lt;code>zeroAddr&lt;/code>&lt;/li>
&lt;li>获取当前线程 m 的乐观锁，&lt;code>m.mallocing = 1&lt;/code>&lt;/li>
&lt;li>如果类型 typ 内没有指针，且小于 &lt;code>maxTinySize&lt;/code> 16 字节，则尝试从当前 &lt;code>P.mcache&lt;/code> 的 &lt;code>tinyAllocs&lt;/code> 申请内存（&lt;code>tinyAllocs&lt;/code> 内存申请只需要计算在 tiny 缓存区的偏移量，性能很高）；没有 tiny 缓存，则依次尝试向 &lt;code>mcache.alloc[tinySpanclass]&lt;/code> 及其上级缓存申请&lt;/li>
&lt;li>如果 &lt;code>size &amp;lt;= maxSmallSize&lt;/code> 32kB，则计算 size 对应的 &lt;code>spanClass&lt;/code>，并一次尝试向 &lt;code>mcache.alloc[tinySpanclass]&lt;/code> 及其上级缓存申请，具体逻辑为：
&lt;ul>
&lt;li>先调用 &lt;code>span = c.alloc[spanClass]; v = nextFreeFast(span)&lt;/code> 从 span 双向链表的当前 span 节点中，使用 &lt;code>allocCache&lt;/code> 标志位快速查找是否存在未使用的缓存，如果有，则直接用此缓存&lt;/li>
&lt;li>否则，调用本地缓存 &lt;code>mcache.nextFree(spanClass)&lt;/code>，此方法先尝试从 &lt;code>span.freeIndex&lt;/code> 之后查找可用缓存，如果没有，说明 span 已满；则调用 &lt;code>mcache.refill(spanClass)&lt;/code> 从全局缓存 &lt;code>mheap.central[spanClass]&lt;/code> 中申请一块有剩余缓存的 span，并调用新 &lt;code>span.nextFreeIndex&lt;/code> 得到内存指针。如果需要从全局缓存获取，则 &lt;code>shouldhelpgc&lt;/code> 设置为 true，后续会触发 GC。&lt;code>central[spanClass]&lt;/code> 用尽时，会调用 &lt;code>mheap_.alloc(npages, spanclass)&lt;/code> 从 mheap 中申请一个有 &lt;code>npages pages&lt;/code> 的 &lt;code>span&lt;/code>（span 根据 spanClass 有不同的大小，多个 pages 组成一个 span）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果 &lt;code>size &amp;gt; maxSmallSize&lt;/code> 32kB，则通过 &lt;code>mcache.allocLarge&lt;/code> 方法，调用 &lt;code>mheap_.alloc(npages, spanclass)&lt;/code> 直接向 &lt;code>mheap&lt;/code> 中申请若干 &lt;code>pages&lt;/code>，组成 &lt;code>span&lt;/code> 并返回。&lt;code>shouldhelpgc&lt;/code> 设置为 &lt;code>true&lt;/code>，后续会触发 GC。&lt;/li>
&lt;/ul>
&lt;p>总结一下，申请无指针的小对象时有 &lt;code>tinyAlloc&lt;/code> 优化措施，中等对象优先尝试从当前 &lt;code>P.mcache&lt;/code> 中申请，没有则依次向全局缓存 &lt;code>mheap.central mheap&lt;/code> 中申请，大对象直接从 &lt;code>mheap&lt;/code> 中申请。申请过程中，如果 &lt;code>P.mcache&lt;/code> 用尽或申请了大对象，都会触发 GC。内存的释放在 GC 过程。&lt;/p>
&lt;h3 id="垃圾回收">
&lt;a href="#%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
垃圾回收
&lt;/h3>
&lt;p>GC 开始的入口在 &lt;code>mgc.go/gcStart(gcTrigger)&lt;/code>，查看此函数的所有调用可以了解到 GC 触发的场景有:&lt;/p>
&lt;ul>
&lt;li>堆内存申请时 &lt;code>P.mcache&lt;/code> 用尽，或申请了大于 32kB 的对象&lt;/li>
&lt;li>用户程序调用 &lt;code>runtime.GC()&lt;/code>&lt;/li>
&lt;li>&lt;code>forcegchelper&lt;/code> 协程定时触发 GC&lt;/li>
&lt;/ul>
&lt;p>Go 的三色标记法的大致流程：短暂 STW，为每个 &lt;code>P&lt;/code> 上创建一个 &lt;code>G&lt;/code>，用于垃圾回收的标记阶段；标记阶段完成后，触发清扫阶段，清扫阶段需要 STW。标记阶段采用三色标记法：&lt;strong>先把所有的根对象标记为灰色并放到任务队列，然后持续从任务队列取出灰色对象，并标记为黑色，把它的指针指向的对象标记为灰色，入工作队列，持续此过程直到工作队列为空&lt;/strong>；为了防止标记协程与用户协程出现并发问题，使用混合写屏障&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>将被覆盖的对象标记成灰色，并在当前栈没有扫描时将新对象也标记成灰色；在 &lt;code>mallocgc&lt;/code> 函数里，把新创建的对象标记为黑色。&lt;/p>
&lt;p>垃圾回收入口 &lt;code>gcStart&lt;/code> 的主要流程：&lt;/p>
&lt;ul>
&lt;li>启动与 &lt;code>P&lt;/code> 数量相同的协程用于并发标记，每个 &lt;code>P&lt;/code> 上跑一个标记协程 &lt;code>gcBgMarkWorker&lt;/code>&lt;/li>
&lt;li>&lt;code>stopTheWorldWithSema&lt;/code> 暂停世界&lt;/li>
&lt;li>处理一些 GC 前置的工作，例如 GC、CPU 限制，GC 状态修改，初始化堆标记 work（标记的工作队列），标记 &lt;code>TinyObjects&lt;/code> 等&lt;/li>
&lt;li>&lt;code>startTheWorldWithSema&lt;/code> 继续调度协程，&lt;code>gcBgMarkWorker&lt;/code> 被调度后会进行标记动作&lt;/li>
&lt;/ul>
&lt;p>标记协程 &lt;code>gcBgMarkWorker&lt;/code> 流程：&lt;/p>
&lt;ul>
&lt;li>通过 &lt;code>gcController.findRunnableGCWorker&lt;/code> 被唤醒调度&lt;/li>
&lt;li>调用 &lt;code>gcDrain&lt;/code>，先扫所有根对象 &lt;code>nDataRoots, nBSSRoots, nSpanRoots, nStackRoots&lt;/code>，然后循环调用 &lt;code>scanobject&lt;/code> 标记工作队列里的对象；工作队列分为本地工作队列 &lt;code>P.gcw&lt;/code> 和全局工作队列，标记过程中会对本地和全局工作队列进行平衡，比如本地队列满了，则会拿出一部分放到全局队列&lt;/li>
&lt;li>检测到标记结束后，会调用 &lt;code>gcMarkDone&lt;/code>，暂停世界，并调用 &lt;code>gcMarkTermination -&amp;gt; gcSweep -&amp;gt; sweepone&lt;/code> 进行清扫，最后通过调用 &lt;code>mheap.freeSpan(span)&lt;/code> 把空 &lt;code>span&lt;/code> 放回堆里；&lt;code>sweep&lt;/code> 结束后，唤醒 &lt;code>scavenger&lt;/code>，把空余内存和不使用的页还给操作系统&lt;/li>
&lt;li>启动世界，继续调度&lt;/li>
&lt;/ul>
&lt;p>并发标记能够解决垃圾回收时暂停世界时间过长的问题，Go 的垃圾回收主要在清扫阶段暂停世界。标记任务通过本地队列、全局队列进行两级存储，本地队列无锁性能高，全局队列可以平衡不同协程之间的工作量。&lt;/p>
&lt;h3 id="协程创建与调度">
&lt;a href="#%e5%8d%8f%e7%a8%8b%e5%88%9b%e5%bb%ba%e4%b8%8e%e8%b0%83%e5%ba%a6" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
协程创建与调度
&lt;/h3>
&lt;p>&lt;code>go&lt;/code> 关键字会在编译时转换为对 &lt;code>proc.go/newproc(fn)&lt;/code> 的调用，它会调用 &lt;code>newproc1(fn, currentG, currentCallerPc)&lt;/code> 创建协程，并通过 &lt;code>runqput(currentP, newg, true)&lt;/code> 加到运行队列：&lt;/p>
&lt;ul>
&lt;li>&lt;code>runqput&lt;/code> 第三个参数为 true 表示会把 &lt;code>newg&lt;/code> 加到本地 &lt;code>P&lt;/code> 的 &lt;code>next slot&lt;/code>，也即本地 &lt;code>P&lt;/code> 下次调度的 &lt;code>G&lt;/code> 就是刚创建的 &lt;code>newg&lt;/code>（如果过程中创建了新的 &lt;code>G&lt;/code>，则又会被新的 &lt;code>G&lt;/code> 抢占 &lt;code>next slot&lt;/code>）&lt;/li>
&lt;li>&lt;code>runqput&lt;/code> 先尝试把 &lt;code>G&lt;/code> 加到容量为 256 的本地队列（无锁），如果本地队列已满，则把 &lt;code>newg&lt;/code> 和本地队列的一半 &lt;code>G&lt;/code> 放到全局队列&lt;/li>
&lt;/ul>
&lt;p>&lt;code>newproc1&lt;/code> 创建协程的主要流程：&lt;/p>
&lt;ul>
&lt;li>调用 &lt;code>gfget&lt;/code> 尝试从 &lt;code>P&lt;/code> 本地 &lt;code>freelist&lt;/code> 获取一个被回收的 &lt;code>G&lt;/code>，本地如果没有，则从全局 &lt;code>freelist&lt;/code> 获取 32 个 &lt;code>G&lt;/code> 到本地；得到 &lt;code>G&lt;/code> 后会判断是否有栈，没有的话会调用 &lt;code>stackalloc&lt;/code> 申请栈空间&lt;/li>
&lt;li>如果 &lt;code>freelist&lt;/code> 没有可用 &lt;code>G&lt;/code>，则调用 &lt;code>malg&lt;/code> 创建新的 &lt;code>G&lt;/code>，并申请栈空间&lt;/li>
&lt;li>设置栈指针 &lt;code>SP&lt;/code>&lt;/li>
&lt;li>设置 &lt;code>sched.pc&lt;/code> 为 &lt;code>goexit&lt;/code>，这样每个协程最后退出时都会执行 &lt;code>goexit&lt;/code>&lt;/li>
&lt;li>设置 &lt;code>startpc&lt;/code> 为用户协程函数 &lt;code>fn&lt;/code>&lt;/li>
&lt;li>修改 &lt;code>G&lt;/code> 的状态为 &lt;code>_Grunnable&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>触发调度的场景有很多，调度的最终入口都在 &lt;code>proc.go/schedule()&lt;/code>。触发调度的情况有：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>主动挂起&lt;/strong>：&lt;code>gopark&lt;/code> -&amp;gt; &lt;code>park_m&lt;/code>，状态修改为 &lt;code>_Gwaiting&lt;/code>，通常发生在 &lt;code>channel&lt;/code> 阻塞，等待 &lt;code>time&lt;/code>、&lt;code>netpoll&lt;/code> 等；&lt;code>pack_m&lt;/code> 会把 &lt;code>G-M&lt;/code> 解绑，并等待调用 &lt;code>goready&lt;/code> 后，修改为 &lt;code>_Grunnable&lt;/code> 并调用 &lt;code>runqput&lt;/code> 加入到运行队列&lt;/li>
&lt;li>&lt;strong>系统调用&lt;/strong>：&lt;code>cgocall&lt;/code> -&amp;gt; &lt;code>entersyscall/exitsyscall&lt;/code>，系统调用开始与退出。&lt;code>entersyscall&lt;/code> 进入系统调用，保存 &lt;code>SP/PC&lt;/code>，&lt;code>M-P&lt;/code> 解绑并记录 &lt;code>P&lt;/code> 为 &lt;code>m.oldp&lt;/code>，状态修改为 &lt;code>_Gsyscall&lt;/code>，P 的状态也为 &lt;code>_Psyscall&lt;/code>；&lt;code>exitsyscall&lt;/code> 已退出系统调用，状态修改为 &lt;code>_Grunnable&lt;/code>，并把 &lt;code>G&lt;/code> 加入到 &lt;code>oldp&lt;/code> 运行队列&lt;/li>
&lt;li>&lt;strong>协作式调度&lt;/strong>：&lt;code>GC&lt;/code> 阶段，信号触发，以及用户程序都可以调用 &lt;code>Gosched&lt;/code>&lt;/li>
&lt;li>&lt;strong>系统监控&lt;/strong>：&lt;code>sysmon&lt;/code> -&amp;gt; &lt;code>retake&lt;/code>，如果当前 &lt;code>G&lt;/code> 已运行（或 &lt;code>P&lt;/code> 陷入系统调用）超过 10ms，则调用 &lt;code>preemptone&lt;/code> 通过信号 &lt;code>sigPreempt&lt;/code> 发送抢占请求&lt;/li>
&lt;/ul>
&lt;p>&lt;code>schedule&lt;/code> 先调用 &lt;code>findRunable&lt;/code> 找到一个等待运行的 &lt;code>G&lt;/code>，然后调用 &lt;code>execute&lt;/code> 执行它。&lt;/p>
&lt;p>&lt;code>findRunable&lt;/code> 查找一个可运行 &lt;code>G&lt;/code> 的顺序：&lt;/p>
&lt;ul>
&lt;li>以 1/61 的概率从全局待运行队列里查找一个&lt;/li>
&lt;li>从 &lt;code>P&lt;/code> 的本地 &lt;code>runq&lt;/code> 中查找&lt;/li>
&lt;li>本地没有，则从全局 &lt;code>runq&lt;/code> 中查找，并拿一部分 &lt;code>G&lt;/code> 到本地&lt;/li>
&lt;li>调用 &lt;code>netpoll&lt;/code> 从网络轮询器中查找是否有就绪的 &lt;code>G&lt;/code>&lt;/li>
&lt;li>从其他 &lt;code>P&lt;/code> 中偷取&lt;/li>
&lt;li>会再次尝试全局队列及网络轮询器&lt;/li>
&lt;li>重复上述过程，直到找到一个就绪的 &lt;code>G&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;code>execute&lt;/code> 会把当前 &lt;code>G-M&lt;/code> 解绑，把要运行的 &lt;code>G&lt;/code> 与 &lt;code>M&lt;/code> 绑定，最后调用 &lt;code>gogo(&amp;amp;g.sched)&lt;/code> 恢复 &lt;code>G&lt;/code> 的执行上下文，并继续执行。&lt;/p>
&lt;p>此流程里并没有把当前的 &lt;code>G&lt;/code> 重新入待运行队列的操作，因为 P 的本地队列是一个 &lt;code>[256]uintptr&lt;/code> 数组，以及两个指针 &lt;code>head tail&lt;/code>，当前 &lt;code>G&lt;/code> 本身就处于 &lt;code>head&lt;/code> 和 &lt;code>tail&lt;/code> 之间。&lt;code>P&lt;/code> 中关于 &lt;code>G&lt;/code> 的一些字段如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">type&lt;/span> &lt;span class="nx">p&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">runqhead&lt;/span> &lt;span class="kt">uint32&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">runqtail&lt;/span> &lt;span class="kt">uint32&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">runq&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">256&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="nx">guintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">runnext&lt;/span> &lt;span class="nx">guintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Available G&amp;#39;s (status == Gdead)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nx">gFree&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">gList&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">n&lt;/span> &lt;span class="kt">int32&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Go 协程退出时会调用汇编程序里的 &lt;code>goexit&lt;/code>，最终调用 &lt;code>goexit0(g)&lt;/code> 来结束协程。它把 &lt;code>G&lt;/code> 的状态设置为 &lt;code>_Gdead&lt;/code>，并回收 &lt;code>G&lt;/code> 的资源，最后触发调度。回收资源包括：&lt;/p>
&lt;ul>
&lt;li>把栈加入到 &lt;code>GC&lt;/code> 扫描栈，用于释放栈引用的堆内存；&lt;/li>
&lt;li>解绑 &lt;code>M&lt;/code>；&lt;/li>
&lt;li>如果栈空间大于初始的 2kB，回收整个栈；&lt;/li>
&lt;li>把 &lt;code>G&lt;/code> 加入到本地 &lt;code>P.gFree&lt;/code>，如果 &lt;code>P.gFree.number &amp;gt; 64&lt;/code>，则把一半的 &lt;code>dead G&lt;/code> 加入到全局 &lt;code>gFree&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="总结">
&lt;a href="#%e6%80%bb%e7%bb%93" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
总结
&lt;/h2>
&lt;p>Go 运行时初始化阶段进行了运行环境读取（操作系统内核数、页大小、环境变量、参数等）及一些初始化工作（各种内存分配器初始化、随机/hash 算法初始化，&lt;code>P&lt;/code> 及应用程序的 init 函数）。&lt;/p>
&lt;p>Go 的垃圾回收经过多个版本的迭代，已经非常成熟，通过在各个 P 上并发标记，大大减少了 STW 的时间。&lt;/p>
&lt;p>运行时的设计充分体现了多级缓存的思想：堆、栈内存的分配设立了本地/全局缓存，堆对象的内存申请也很多对象大小进行分级，使用 &lt;code>spanClass&lt;/code> 把对象进行分类，不仅加快分配速度，还减少了空间碎片；协程调度、协程创建与回收，也使用本地/全局缓存，降低锁争用的发生。这种多级缓存、按类分配的思想能给我们在做系统设计时提供启发。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>&lt;a href="https://cbsheng.github.io/posts/%E6%8E%A2%E7%B4%A2golang%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">探索 golang 启动过程&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>&lt;a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-stack-management/#%E6%A0%88%E6%89%A9%E5%AE%B9">draveness Go 语言设计与实现，栈扩容&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>&lt;a href="https://geektutu.com/post/hpg-escape-analysis.html">极客兔兔 Go 语言高性能编程，内存逃逸&lt;/a>&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>&lt;a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9C">draveness Go 语言设计与实现，混合写屏障&lt;/a>&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Raft 协议核心内容</title><link>https://xiang-xx.github.io/posts/raft-protocol/</link><pubDate>Wed, 01 Mar 2023 19:26:36 +0800</pubDate><guid>https://xiang-xx.github.io/posts/raft-protocol/</guid><description>
&lt;h2 id="关于-raft">
&lt;a href="#%e5%85%b3%e4%ba%8e-raft" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
关于 raft
&lt;/h2>
&lt;p>Raft&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> 是一种共识算法，它能够使得系统成员部分失效后，系统仍然能够工作。本质上是一个备份状态机，它具有以下特性：&lt;/p>
&lt;ul>
&lt;li>安全性：永远不会返回错误数据（尽管存在拜占庭故障、网络分区、延迟、丢包等）&lt;/li>
&lt;li>高可用：只要大多数节点存活（互相之间能通讯，能被客户端访问到），系统就是可用的&lt;/li>
&lt;li>共识日志不依赖时间（因为系统可能存在时间故障、严重延迟等）&lt;/li>
&lt;li>一般情况下，只要集群大多数响应命令完成，则此命令就会完成，避免少量慢节点影响整体服务性能&lt;/li>
&lt;/ul>
&lt;p>Raft 部分思想受 Paxos、zab 等协议启发，但 Raft 协议简单很多：作者在论文中多次强调 Paxos 过于复杂，他们花了一年时间才真正搞懂 Paxos 究竟是如何工作的。而 Raft 协议的初衷就是创建一个更简单的共识算法，更简单意味着可以被更多人学习、理解，能更好的在生产中实现、使用。&lt;/p>
&lt;p>&lt;a href="http://thesecretlivesofdata.com/raft/">这个网站&lt;/a>&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>使用分步动画形式很好的解释了 raft 的运行方式，通过它可以对 raft 协议有大致的认识。&lt;/p>
&lt;h2 id="raft-共识算法概要">
&lt;a href="#raft-%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95%e6%a6%82%e8%a6%81" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
Raft 共识算法概要
&lt;/h2>
&lt;p>Raft 算法要求先选出 leader，然后 leader 接收客户端的 log entries，复制给其他 servers，并告诉它们什么时候可以把 log entries 应用到它们的状态机。&lt;/p>
&lt;p>Raft 协议把共识算法分解成三个互相无依赖的子问题：&lt;/p>
&lt;ul>
&lt;li>Leader election：当现有的 leader 失效后，必须选举出新 leader&lt;/li>
&lt;li>Log replication：leader 从客户端接收 log entries，并复制到集群的其他 servers 上&lt;/li>
&lt;li>Safety：如果一个 server 把某个 log entry 应用到它的状态机，则集群其他 server 与此 log entry 相同的 log index 上，使用的都是同一个 log entry.&lt;/li>
&lt;/ul>
&lt;h2 id="raft-详细内容">
&lt;a href="#raft-%e8%af%a6%e7%bb%86%e5%86%85%e5%ae%b9" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
Raft 详细内容
&lt;/h2>
&lt;h3 id="所有服务器的持久状态persistent-state">
&lt;a href="#%e6%89%80%e6%9c%89%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%9a%84%e6%8c%81%e4%b9%85%e7%8a%b6%e6%80%81persistent-state" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
所有服务器的持久状态（persistent state）：
&lt;/h3>
&lt;ul>
&lt;li>currentTerm: 服务器上次看到的 term&lt;/li>
&lt;li>votedFor: 当前 term 收到投票的服务器ID，如果没有，是 null&lt;/li>
&lt;li>log[]: log entries，从 leader 接收到的每个 entry 都包含状态机的命令，和当时的 term&lt;/li>
&lt;/ul>
&lt;h3 id="所有服务器的不稳定状态-volatile-state">
&lt;a href="#%e6%89%80%e6%9c%89%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%9a%84%e4%b8%8d%e7%a8%b3%e5%ae%9a%e7%8a%b6%e6%80%81-volatile-state" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
所有服务器的不稳定状态 （volatile state）：
&lt;/h3>
&lt;ul>
&lt;li>commitIndex: 已知需要提交的最高 log 的 index&lt;/li>
&lt;li>lastApplied: 已经应用到状态机的最高 log 的 index&lt;/li>
&lt;/ul>
&lt;h3 id="leader-服务器的不稳定状态选举后重新初始化">
&lt;a href="#leader-%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%9a%84%e4%b8%8d%e7%a8%b3%e5%ae%9a%e7%8a%b6%e6%80%81%e9%80%89%e4%b8%be%e5%90%8e%e9%87%8d%e6%96%b0%e5%88%9d%e5%a7%8b%e5%8c%96" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
leader 服务器的不稳定状态（选举后重新初始化）
&lt;/h3>
&lt;ul>
&lt;li>nextIndex[] 需要发送给特定 server 的下一个 entry 的 index（初始化为 leader last log index + 1）&lt;/li>
&lt;li>matchIndex[] 已知在每个 server 上已复制的 index&lt;/li>
&lt;/ul>
&lt;h3 id="appendentries-rpc">
&lt;a href="#appendentries-rpc" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
AppendEntries Rpc
&lt;/h3>
&lt;p>leader 调用用来备份 entries；同时也是用来作为心跳的 rpc
参数：&lt;/p>
&lt;ul>
&lt;li>term: leader 的 term&lt;/li>
&lt;li>leaderId: follower 可以据此重定向 client 的请求&lt;/li>
&lt;li>entries[]: 同步的命令，可以为空&lt;/li>
&lt;li>prevLogIndex: entries 前一个 entry 的索引&lt;/li>
&lt;li>prevLogTerm: prevLogIndex 的 term&lt;/li>
&lt;li>leaderCommit leader 的提交索引&lt;/li>
&lt;/ul>
&lt;p>响应：&lt;/p>
&lt;ul>
&lt;li>term：接收端 currentTerm，leader 可以根据响应更新自己的状态。（比如 leader 落后 term，变为 follower）&lt;/li>
&lt;li>success: 如果 follower 包含对应的 prevLogIndex 和 prevLogTerm，则是 true&lt;/li>
&lt;/ul>
&lt;p>接收端实现：&lt;/p>
&lt;ol>
&lt;li>如果 term &amp;lt; currentTerm，return false&lt;/li>
&lt;li>如果 prevLogIndex， prevLogTerm 不存在，则 return false&lt;/li>
&lt;li>如果已存在的 entry 与 new entries 冲突（相同 index，不同 term），删除现有的 entry，使用 leader 的 entries&lt;/li>
&lt;li>新的 entries 全部 append 到 log 中&lt;/li>
&lt;li>如果 leaderCommit &amp;gt; commitIndex, 把 commitIndex 设置为 min(leaderCommit, index of last new entry)&lt;/li>
&lt;/ol>
&lt;h3 id="requestvote-rpc">
&lt;a href="#requestvote-rpc" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
RequestVote Rpc
&lt;/h3>
&lt;p>候选人调用，获取选票。&lt;/p>
&lt;p>参数：&lt;/p>
&lt;ul>
&lt;li>term: 候选人的 term&lt;/li>
&lt;li>candidateId: 候选人id&lt;/li>
&lt;li>lastLogIndex: 候选人最后一条 log entry 的 index&lt;/li>
&lt;li>lastLogTerm: 候选人最后一条 log entry 的 term&lt;/li>
&lt;/ul>
&lt;p>响应：&lt;/p>
&lt;ul>
&lt;li>term: currentTerm，候选人根据此 term 更新自己&lt;/li>
&lt;li>voteGanted: 为 true 表示候选人得到了选票&lt;/li>
&lt;/ul>
&lt;p>接收端实现：&lt;/p>
&lt;ol>
&lt;li>如果 term &amp;lt; currentTerm，则 return false&lt;/li>
&lt;li>如果 votedFor 是 null 或者 candidateId，且候选人日志至少是最新的（比投票人的 lastLogIndex 更新或相同），投票为 true&lt;/li>
&lt;/ol>
&lt;h3 id="servers-的规则">
&lt;a href="#servers-%e7%9a%84%e8%a7%84%e5%88%99" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
Servers 的规则
&lt;/h3>
&lt;p>All Servers:&lt;/p>
&lt;ul>
&lt;li>如果 commitIndex &amp;gt; lastApplied，增加 lastApplied，并把 &lt;code>log[lastApplied]&lt;/code> 应用到状态机&lt;/li>
&lt;li>如果 RPC 请求或响应存在 term T &amp;gt; currentTerm，设置 currentTerm = T，并设置为 follower&lt;/li>
&lt;/ul>
&lt;p>Followers:&lt;/p>
&lt;ul>
&lt;li>响应 candidate 和 leader 的 rpc 调用&lt;/li>
&lt;li>如果选举超时结束，且没有收到 leader 的 AppendEntries RPC 和 candidate 的 RequestVote RPC，则变为 candidate&lt;/li>
&lt;/ul>
&lt;p>Candidate:&lt;/p>
&lt;ul>
&lt;li>当变为 candidate 后，开始选举
&lt;ul>
&lt;li>增加 currentTerm&lt;/li>
&lt;li>投票给自己&lt;/li>
&lt;li>重设 election timer&lt;/li>
&lt;li>向其他 server 发送 RequestVoteRpc&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果收到大多数 server 的选票，变为 leader&lt;/li>
&lt;li>如果收到新 leader 的 AppendEntries RPC，则变为 follower&lt;/li>
&lt;li>election timer 超时，重新开启选举&lt;/li>
&lt;/ul>
&lt;p>Leader:&lt;/p>
&lt;ul>
&lt;li>选举时，发送空 AppendEntriesRPC 到每个 server；空闲期间重复发送，避免选举超时&lt;/li>
&lt;li>收到 client 的命令后：把 entry 追加到本地 log，当 entry 被应用状态机后返回&lt;/li>
&lt;li>如果 follower 的 last log index &amp;gt;= nextIndex，AppendEntryRpc 的 entries 从 nextIndex 开始发送
&lt;ul>
&lt;li>如果 success，更新记录 follower 的 nextIndex 和 matchIndex&lt;/li>
&lt;li>如果 fail，减小 nextIndex，并重试&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果存在 N， N &amp;gt; commitIndex，且大多数的 matchIndex[i] &amp;gt;= N, 且 log[N].term == currentTerm，set commitIndex = N&lt;/li>
&lt;/ul>
&lt;h3 id="安全性保证">
&lt;a href="#%e5%ae%89%e5%85%a8%e6%80%a7%e4%bf%9d%e8%af%81" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
安全性保证
&lt;/h3>
&lt;p>通过以上逻辑，Raft 可以实现下面的安全性保证。&lt;/p>
&lt;p>选举安全：每个 term 只能有一个 leader 被选举出来。&lt;/p>
&lt;p>Leader 日志仅追加（Append-Only）: leader 不会修改或删除它的本地 Log，仅追加。&lt;/p>
&lt;p>日志匹配（Log Matching）: 如果两个 logs 有相同的 index 和 term，则这两个 logs 里所有的 entry 都是相同的。&lt;/p>
&lt;p>Leader 完备（Leader Completeness）: 如果在特定 term 提交了一个 entry，则在所有更高 term 的 leader 里，它都是存在的。&lt;/p>
&lt;p>状态机安全：如果一个 server 已经 apply a entry 到状态机，则相同的 index 下，其他 server apply 的是同一个 entry。&lt;/p>
&lt;p>Leader 只会通过计数本任期 term 下产生的 entry 的备份数量，来提交 entry（设置 commitIndex）。&lt;/p>
&lt;h2 id="其他">
&lt;a href="#%e5%85%b6%e4%bb%96" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
其他
&lt;/h2>
&lt;p>时间与可用性：广播时间 &amp;laquo; 选举超时时间 &amp;laquo; 崩溃间隔。内网广播时间（请求响应一来一回的时间）通常是几毫秒内；崩溃间隔通常几天、几月甚至更长。选举超时时间一般随机设置在 150ms - 300ms，太长会影响 leader 崩溃后系统的恢复速度，太短则可能频发引发选举。&lt;/p>
&lt;p>集群成员改变（增减）：使用 config log entry 同步成员信息，保证配置信息共识。成员初次加入需要同步数据，同步数据时没有投票权，不占大多数计算逻辑；直到追上日志后才能投票。&lt;/p>
&lt;p>日志压缩：快照模式，各个 server 管理自己的快照。快照后，前面的 log entries 可以删除。如果 leader 给 follower 需要同步的日志已删除，需要接口先同步快照，再同步后面的日志。同步快照使用 InstallSnapshot RPC。&lt;/p>
&lt;p>客户端交互：客户端随机选择节点发起请求，如果是 follower 节点，则节点拒绝请求，并返回 leader 信息。客户端向 leader 发起请求。&lt;/p>
&lt;p>为了避免 &lt;strong>leader 已提交但未响应 client 后崩溃，client 重新请求新 leader 节点会导致命令多次执行&lt;/strong>，每个 command 需要带一个唯一标识，新 leader 包含所有已提交 entry，遇到相同的唯一标识的 command，直接返回已执行即可。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>&lt;a href="https://raft.github.io/raft.pdf">Diego Ongaro and John Ousterhout Stanford University&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>&lt;a href="http://thesecretlivesofdata.com/raft/">Raft: Understandable Distributed Consensus&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>读《设计数据密集型应用》</title><link>https://xiang-xx.github.io/posts/read-ddia/</link><pubDate>Sat, 25 Feb 2023 12:12:05 +0800</pubDate><guid>https://xiang-xx.github.io/posts/read-ddia/</guid><description>
&lt;h2 id="前言">
&lt;a href="#%e5%89%8d%e8%a8%80" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
前言
&lt;/h2>
&lt;p>互联网企业里或多或少都会有些数据密集型系统，比如一家互联网教育企业，付费用户虽然不多，但视频观看打点频率高，观看日志的数据量可以很大；一个在线聊天软件，用户聊天数据也会快速增长。《设计数据密集型应用》&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>一书内容丰富，涵盖了数据系统存储细节、分布式、数据一致性等问题，由浅入深，由底层细节到顶层架构，循序渐进地展开一张数据密集型系统的画卷全貌。&lt;/p>
&lt;h2 id="可靠性可伸缩性和可维护性">
&lt;a href="#%e5%8f%af%e9%9d%a0%e6%80%a7%e5%8f%af%e4%bc%b8%e7%bc%a9%e6%80%a7%e5%92%8c%e5%8f%af%e7%bb%b4%e6%8a%a4%e6%80%a7" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
可靠性、可伸缩性和可维护性
&lt;/h2>
&lt;p>与数据密集型系统对应的是计算密集型系统。在互联网行业中，更常见的是数据密集型系统。此书的目标是介绍如何打造&lt;strong>可靠、可伸缩、可维护&lt;/strong>的数据系统。&lt;/p>
&lt;ul>
&lt;li>可靠性：系统在困境中（硬件故障、软件故障、人为错误）仍可以正常工作&lt;/li>
&lt;li>可伸缩性：有合理的办法应对系统的增长（数据量，流量，复杂性）&lt;/li>
&lt;li>可维护性：许多不同的人，在不同的声明周期，都能高效的在系统上工作&lt;/li>
&lt;/ul>
&lt;p>提高可靠性：&lt;/p>
&lt;ul>
&lt;li>硬件：提高冗余度&lt;/li>
&lt;li>软件：彻底的测试、进程隔离、允许崩溃重启、测量/监控/自检/报警等&lt;/li>
&lt;li>人为错误：沙箱环境、只读环境、允许快速回滚、允许数据重算、API 限制、管理后台、人员培训等（最小化犯错误机制，允许犯错并修复，监控错误产生）&lt;/li>
&lt;/ul>
&lt;p>性能：批处理关注吞吐量，在线服务系统关注&lt;strong>响应时间&lt;/strong>。&lt;/p>
&lt;p>通常使用响应时间的高位百分比描述服务性能。比如: 50%的响应小于200ms，99% 的响应时间小于 1s，即 &lt;code>p50&amp;lt;100ms, p99&amp;lt;1s&lt;/code>。&lt;/p>
&lt;p>可伸缩性：纵向伸缩（scaling up），横向伸缩（scaling out）。&lt;/p>
&lt;p>可维护性与软件系统设计的原则：&lt;/p>
&lt;ul>
&lt;li>可操作性：便于（运维团队）维护系统平稳运行&lt;/li>
&lt;li>简单性：从系统中尽可能消除复杂度。减少系统状态、降低模块耦合、理清依赖关系、术语命名一致&amp;hellip;&lt;/li>
&lt;li>可演化性（可扩展性，可塑性）&lt;/li>
&lt;/ul>
&lt;h2 id="数据模型与查询语言">
&lt;a href="#%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b%e4%b8%8e%e6%9f%a5%e8%af%a2%e8%af%ad%e8%a8%80" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
数据模型与查询语言
&lt;/h2>
&lt;p>常见的数据模型：&lt;/p>
&lt;ul>
&lt;li>网状模型（CODASQL 为例）：数据库存在模式；访问特定记录需要遍历其中一条路径；查询是命令式，难以编写和维护&lt;/li>
&lt;li>&lt;strong>关系型：写时模式（schema-on-write）&lt;/strong>；范式设计导致从数据到代码对象需要复杂的转化；能够更好的处理多对多的关系；查询时通常需要遍历更多的数据&lt;/li>
&lt;li>&lt;strong>文档型：读时模式（schema-on-read）&lt;/strong>；代码查询简单；文档引用技术解决多对多的关系；查询局部性相对好；更新文档通常需要整个重写。&lt;/li>
&lt;li>&lt;strong>图模型&lt;/strong>：更适合多对多的关系；顶点和边不仅限于一种类型，顶点可以表示人、地点、事件，边可以表示哪些人彼此是好友、谁参与了哪个事件；适用于社交图谱，网络图谱，公路铁路网络等。&lt;/li>
&lt;li>其他：用于基因相似性检测的搜索引擎（序列相似性搜索）；全文搜索；PB级大数据存储模型。&lt;/li>
&lt;/ul>
&lt;p>声明式查询语言（SQL，mongo，es）：简单容易；隐藏了数据库细节，便于兼容前后版本；适合并行查询。&lt;/p>
&lt;p>命令式查询语言（例如 CODASQL）：类似编程语言的执行逻辑。&lt;/p>
&lt;p>MapReduce 介于声明式和命令式之间，使用代码逻辑编写，但能够并行在多台机器上分布式执行。&lt;/p>
&lt;h2 id="存储与检索">
&lt;a href="#%e5%ad%98%e5%82%a8%e4%b8%8e%e6%a3%80%e7%b4%a2" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
存储与检索
&lt;/h2>
&lt;p>存储引擎的两个大类&lt;/p>
&lt;ul>
&lt;li>日志结构（log-structured）&lt;/li>
&lt;li>面向页面（page-oriented）&lt;/li>
&lt;/ul>
&lt;p>日志结构存储引擎通常是&lt;strong>追加写&lt;/strong>，在机械硬盘上性能较好，崩溃恢复简单，日志文件分段，删除使用特殊的标记，段文件可以后台合并，单独一个写线程避免并发问题。&lt;/p>
&lt;p>日志结构的散列索引：范围查询性能很低；必须能够放在内存里，否则磁盘映射性能很低。&lt;/p>
&lt;p>SSTable 排序字符串表，&lt;strong>LSM（日志文件合并树）&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>每个段文件内 key 是有序的&lt;/li>
&lt;li>多个段文件合并后按照 key 的顺序写入到新段文件&lt;/li>
&lt;li>当前段文件使用有序结构（红黑树等）维护在内存中，磁盘维护当前分段的顺序写日志；达到一定阈值，写入新段文件，删除旧的顺序写日志&lt;/li>
&lt;li>使用 bloom 过滤器，优化不存在的 key 的查找&lt;/li>
&lt;li>有序 key 可以加快范围查询&lt;/li>
&lt;/ul>
&lt;p>面向页面结构的存储引擎通常使用 &lt;strong>B 树&lt;/strong>及其变体作为存储引擎。
&lt;img loading="lazy"
src="https://xiang-xx.github.io/./img/btree.png"
alt="btree"
width=1140
height="658" />&lt;/p>
&lt;ul>
&lt;li>B 树将数据库分解成固定大小的块或页，一次性只能读取或写入一个页面；这种设计接近底层页面，因为磁盘空间也是按照固定大小组织的&lt;/li>
&lt;li>页面之间使用地址（硬盘地址，而非内存地址）互相引用，构建出树&lt;/li>
&lt;li>一个页面的引用数量称为&lt;strong>分支因子&lt;/strong>，通常是几百（分支因子为 500 的 4KB 页面的四层树可以存储 256T 数据）&lt;/li>
&lt;li>使用预写日志（WAL，或重做日志 redo log，追加写文件）实现崩溃恢复&lt;/li>
&lt;li>使用锁控制页面写入&lt;/li>
&lt;li>如果一个页满了，则分裂成两个半页&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>B 树相关优化&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>字符串 key 可以不存储整个键，缩短键大小以增大分支因子&lt;/li>
&lt;li>写时复制，经过修改的页面写入到不同位置，便于并发控制和崩溃恢复&lt;/li>
&lt;li>使叶子页面尽量放在相同的位置&lt;/li>
&lt;li>额外的指针，使用每个叶子页面可以连接左右兄弟页面，顺序扫描不需要跳回父级&lt;/li>
&lt;li>分形树（fractal tree）&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>，在节点上缓存变更操作，接用日志结构的思想减少磁盘查找&lt;/li>
&lt;/ul>
&lt;p>数据仓库的&lt;strong>列式存储&lt;/strong>（在线分析处理 OLAP）：&lt;/p>
&lt;ul>
&lt;li>每个列存储在单独的文件，所有列包含的行的顺序是对应的，可以通过列构建出行&lt;/li>
&lt;li>数仓事实表的列通常很多，数据分析时只关心若干列，没必要把其他列读出来&lt;/li>
&lt;li>列数据存储在一起便于压缩，比如有些列只有若干可能的值，通过位图编码可以极大压缩；列排序后对于压缩更友好&lt;/li>
&lt;li>使用 LSM，分批次写入数据，降低大量数据写入的瓶颈&lt;/li>
&lt;li>物化视图，对于 count、sum、svg、max 等数据物化存储，便于查询&lt;/li>
&lt;/ul>
&lt;h2 id="编码和演化">
&lt;a href="#%e7%bc%96%e7%a0%81%e5%92%8c%e6%bc%94%e5%8c%96" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
编码和演化
&lt;/h2>
&lt;p>常用的文本格式编码：json，xml，csv；易读，但数据量相对大；二进制编码：protobuf，thrift；数据量通常能压缩 20% 以上，缺点是不可读；编程语言特定的编码仅限于单一语言，通常不使用。&lt;/p>
&lt;h2 id="复制">
&lt;a href="#%e5%a4%8d%e5%88%b6" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
复制
&lt;/h2>
&lt;p>&lt;strong>主从模式&lt;/strong>是比较常见的模式模式。Mysql、redis、PostgreSQL、kafka 等都是用主从模式。&lt;/p>
&lt;p>同步复制：主库等待从库复制完成再响应请求。能够保证从库与主库数据一致，主库不可用时，从库包含完整的数据。但如果从库故障，主库也无法写入。&lt;/p>
&lt;p>半同步：一个从库使用同步复制，其他从库是异步的。确保有一个从库是同步复制的。&lt;/p>
&lt;p>异步复制：主库的写入不能保证持久。&lt;/p>
&lt;p>&lt;strong>复制的实现&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>基于语句的复制：使用非确定性的语句、函数，以及现有数据不一致时，可能导致语句在从库上产生的效果不同。&lt;/li>
&lt;li>基于预写日志复制（WAL）：预写日志通常涉及到底层存储，比如覆写某个磁盘页，不同版本之间可能不兼容。&lt;/li>
&lt;li>&lt;strong>基于行的逻辑日志复制&lt;/strong>（例如 binlog）：将复制日志从存储引擎中解耦出来，且对于外部来说，逻辑日志更容易解析，便于发送到外部系统中处理&lt;/li>
&lt;li>基于触发器的复制：灵活性强，但开销比较高。&lt;/li>
&lt;/ul>
&lt;p>异步复制因为网络延迟的存在，只提供最终一致性。&lt;/p>
&lt;p>&lt;strong>读己之写&lt;/strong>：用户提交完数据想要立刻查看，则新数据未到达副本，可能导致未查到，像是数据丢失。确保写后读一致性的一些方式：&lt;/p>
&lt;ul>
&lt;li>对于用户可能修改过的数据，总是从主库读。比如用户读取自己的个人信息走主库，读取其他人的信息走从库&lt;/li>
&lt;li>如果应用的大部分内容都可能被用户编辑，则可以跟踪上次更新时间来决定是否读从库。还可以监控从库延迟&lt;/li>
&lt;li>客户端可以记录最后一次写入的 逻辑时间戳，据此判断是否读从库&lt;/li>
&lt;li>如果副本分布在不同地理位置的数据中心，则更复杂。任何需要主库提供服务的请求，都需要被路由到主库所在的数据中心&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>单调读&lt;/strong>：确保每个用户总是从一个副本读取，避免来回切换延迟时间不同的副本，导致读的数据一会儿有一会儿没有。&lt;/p>
&lt;p>&lt;strong>一致前缀读&lt;/strong>：具有因果关系的一系列数据写入后，读取这些数据也必须按照相同的顺序出现。比如 A，B 两个有因果关系的事件先后写入数据库后，用户读从库的时候不能只读到 B 但没有读到 A。通常在分片或分区数据库中会出现这种场景，需要确保具有因果关系的事件写入到相同分区。&lt;/p>
&lt;p>&lt;strong>多主复制&lt;/strong>的使用场景：&lt;/p>
&lt;ul>
&lt;li>运维多个数据中心，数据就近访问，降低地理位置导致的延迟&lt;/li>
&lt;li>需要离线处理的客户端，比如印象笔记&lt;/li>
&lt;li>协同编辑&lt;/li>
&lt;/ul>
&lt;p>多主复制最大的问题是写入冲突。&lt;/p>
&lt;ul>
&lt;li>避免冲突：对相同记录的操作路由到同一个数据中心&lt;/li>
&lt;li>收敛至一致的状态：每个写分配一个 ID，冲突时 ID 大的覆盖小的（数据丢失）；以某种方式把值合并在一起；编写解决冲突的代码。&lt;/li>
&lt;/ul>
&lt;p>多主复制的一些拓扑：
&lt;img loading="lazy"
src="https://xiang-xx.github.io/./img/mmcopy.png"
alt="mmcopy"
width=1120
height="336" />&lt;/p>
&lt;p>&lt;strong>无主复制&lt;/strong>：客户端直接将写入发送到多个副本（通常会有个协调者节点，代替客户端写入，节点之间没有固定写入顺序）。无主复制处理节点数据不一致方案：&lt;/p>
&lt;ul>
&lt;li>读修复：读取时，修复陈旧的节点数据（冷数据可能用于读不到，不会修复）&lt;/li>
&lt;li>反熵过程：后台进程不断查找副本差异，修复数据&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>读写的法定人数&lt;/strong>：假设有 n 和副本，w 个副本确认表示写入成功，读取时需要从 r 个副本读取&lt;/p>
&lt;ul>
&lt;li>需要确保 w+r &amp;gt; n，这样读的副本里至少有一个是最新的&lt;/li>
&lt;li>通常 w = r = (n+1)/2&lt;/li>
&lt;li>w 越大，r 越小；则 读取效率高，写入效率低，适合读多写少的系统；&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>检测并发写入&lt;/strong>：多个客户端可以同时对一个 key 写入，但写操作可能按照不同顺序到达不同节点。并发写入规避方案：&lt;/p>
&lt;ul>
&lt;li>LWW 最后写入胜利：每个请求加一个时间戳，大的覆盖小的&lt;/li>
&lt;li>一个键只允许写入一次，不允许更新&lt;/li>
&lt;li>写入前先读取，读取值包含版本号，写入时传入版本号，只能覆盖相同或更低的版本号&lt;/li>
&lt;li>使用客户端程序合并写入&lt;/li>
&lt;li>版本向量：对于一个键值，所有副本的版本号的集合成为版本向量，读取值时，版本向量会发送给客户端，写入时需要传给数据库。版本向量允许数据库区分覆盖写入和并发写入。&lt;/li>
&lt;/ul>
&lt;h2 id="分区">
&lt;a href="#%e5%88%86%e5%8c%ba" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
分区
&lt;/h2>
&lt;p>分区通常和复制同时使用，每个分区的副本存储在多个节点上。如果分区是不公平的，则一些分区比其他分区有更多的数据和查询，产生&lt;strong>数据偏斜&lt;/strong>，导致分区效率下降。&lt;/p>
&lt;p>根据键的&lt;strong>范围分区&lt;/strong>。例如百科全书按照关键字的分区。分区边界可以由管理员手动选择，也可以由数据库自动选择。Bigtable/HBase 使用类似方法。优点是存在顺序性，便于范围查找；但容易造成数据倾斜。比如键中带有时间戳 &amp;ndash; 可以在时间戳前面加上其他的字段。&lt;/p>
&lt;p>根据键的&lt;strong>散列分区&lt;/strong>。好的散列函数可以把键均匀分布，但范围查询效率低。&lt;/p>
&lt;p>Cassandra 的折衷策略：主键采用多个列组成，第一个列用作 hash 分区，后续键使用 SSTables 排序；如果指定了第一个键查询，则后续的键可以范围查找。&lt;/p>
&lt;p>&lt;strong>负载偏斜与热点消除&lt;/strong>：极端情况下，某些键会被大量的读取写入，比如热点微博的数据；这种热点数据或造成分区的负载偏斜。解决方案：使用一定策略，判断这些键需要被额外分区，比如后面加上后缀，{id}_0,{id}_1&amp;hellip; 把热点数据分成若干份，存储在不同分区，读取的时候再进行合并。&lt;/p>
&lt;p>&lt;strong>基于文档的次级索引进行分区&lt;/strong>。即每个分区维护自己分区内文档的次级索引，查询的时候并发从各个分区查询；这种方案比较简单，但并发多条查询容易导致尾部延迟放大。&lt;/p>
&lt;p>&lt;strong>基于关键词（term）的次级索引进行分区&lt;/strong>。构建覆盖所有分区数据的全局索引，全局索引也需要分区，可以采用与主键不同的分区方式。 关键词分区；关键词（term）源自全文搜索引擎，指文档中出现的所有单词。这种次级索引分区方式写入速度慢，且比较复杂；在实践中，对全局索引的更新通常是异步的。&lt;/p>
&lt;p>分区&lt;strong>再平衡&lt;/strong>策略：&lt;/p>
&lt;ul>
&lt;li>反面教材：hash mod n，导致再平衡发生时大量数需要移动&lt;/li>
&lt;li>&lt;strong>固定数量的分区&lt;/strong>：分区数量比节点数量多，比如 5个节点，100 个分区，如果一个节点挂了，则另外四个节点均分挂掉的 20 个分区。 Riak/ES/CouchBase/Voldemort 都使用这种策略&lt;/li>
&lt;li>动态分区：分区增长到一定大小时，会被分成两个分区，各拥有一半数据；如果大量数据删除，分区变小，则可以合并分区。动态分区同时支持 hash 分区和范围分区。 HBase/MongoDB&lt;/li>
&lt;li>按节点比例分区：分区数与节点数成正比，即每个节点具有固定数量的分区，通常每个节点的分区数比较多，以保证数据的平衡。Cassandra 中，每个节点默认 256 个分区。&lt;/li>
&lt;/ul>
&lt;p>分区&lt;strong>请求路由&lt;/strong>方式：&lt;/p>
&lt;ul>
&lt;li>允许客户连接任何节点（通过循环策略的负载均衡，Round-Robin Load Balancer），如果节点有请求的分区，则直接处理请求；否则，它转发到其他节点，收到回复并返回给客户端&lt;/li>
&lt;li>将客户的请求发送到路由层，它决定应该处理请求的节点，并进行转发&lt;/li>
&lt;li>要求客户端知道分区和节点的分配&lt;/li>
&lt;/ul>
&lt;h2 id="事务">
&lt;a href="#%e4%ba%8b%e5%8a%a1" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
事务
&lt;/h2>
&lt;p>&lt;strong>事务的 ACID&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>原子性（Atomicity）：能够在错误时中止事务，丢弃该事务的所有写入变更的能力&lt;/li>
&lt;li>一致性（Consistency）：对数据的一组特定约束始终不变&lt;/li>
&lt;li>隔离性（Isolation）：同时执行的事务是相互隔离的。&lt;/li>
&lt;li>持久性（Durability）：持久性是一个承诺，即一旦事务完成，即使发生硬件故障或数据库崩溃，写入的任何数据也不会丢失。完美的持久性是不存在的。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>非事务的 BASE&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>基本可用性（Basically Available）&lt;/li>
&lt;li>软状态（Soft State）&lt;/li>
&lt;li>最终一致性（Eventual Consistency）&lt;/li>
&lt;/ul>
&lt;p>对于应用而言，没有事务，错误处理复杂很多；没有隔离性，就会导致并发问题。&lt;/p>
&lt;p>可串行化的隔离级别保证事务的执行效果如同串行发生；会有严重的性能损失，一般数据库不使用。一般事务只使用弱的隔离级别。&lt;/p>
&lt;p>&lt;strong>读已提交&lt;/strong>：提供了两个保证&lt;/p>
&lt;ul>
&lt;li>从数据库读时，只能看到已提交的数据，没有脏读&lt;/li>
&lt;li>写入数据库时，只能看到已提交的数据，没有脏写&lt;/li>
&lt;/ul>
&lt;p>数据库使用 行锁 来防止脏写（两阶段锁协议）&lt;/p>
&lt;p>&lt;strong>快照隔离 和 可重复读&lt;/strong>：一些情况下无法容忍同一个事务多次读的数据不一致（或一致性遭破坏）&lt;/p>
&lt;ul>
&lt;li>备份；如果备份了一部分新 一部分旧的数据，会破坏一致性&lt;/li>
&lt;li>分析查询和完整性查询：需要扫描大量的数据，不一致的数据可能导致完整性损坏&lt;/li>
&lt;/ul>
&lt;p>快照隔离的实现：&lt;/p>
&lt;ul>
&lt;li>使用写锁防止脏写&lt;/li>
&lt;li>读取不需要加锁，性能方面：读不阻塞写，写不阻塞读&lt;/li>
&lt;li>多版本并发控制（MVCC）：维护单个对象的多个版本，mysql 使用 undolog 实现访问旧版本；读已提交为每个查询使用单独的快照；可重复读（快照隔离）对整个事务使用相同的快照&lt;/li>
&lt;li>每一行都有 created_by 和 deleted_by 字段，存储它被创建，被删除的事务ID&lt;/li>
&lt;li>update 操作在内部被翻译成 delete 和 insert 操作&lt;/li>
&lt;/ul>
&lt;p>事务 ID 决定了它能看到哪些对象：&lt;/p>
&lt;ul>
&lt;li>每次事务开始时，数据库列出当时其他（尚未提交或尚未中止）的事务清单，即使后续提交了，这些事务已执行的任何写入也都会被忽略&lt;/li>
&lt;li>被终止事务写入的任何执行都会被忽略&lt;/li>
&lt;li>有具有较晚事务的事务ID所作的任何写入都会被忽略&lt;/li>
&lt;li>所有其他写入，对应用是可见的&lt;/li>
&lt;/ul>
&lt;p>防止丢失更新的场景与办法：（事务执行顺序为 读 - 修改 - 写入序列，可能导致写入互相覆盖，丢失更新数据）&lt;/p>
&lt;ul>
&lt;li>原子写： &lt;code>update x set val = val +1 where y=b;&lt;/code>&lt;/li>
&lt;li>显式锁定：&lt;code>select * from xx where a = b for update;&lt;/code>&lt;/li>
&lt;li>自动检测丢失的更新：postgresql 的可重复读会自动检测丢失更新，并中止惹麻烦的事务；mysql 的 Innodb 不会。一些人认为&lt;strong>能够自动检测丢失的跟更新&lt;/strong>才称得上是快照隔离&lt;/li>
&lt;li>CAS，比较并设置，&lt;code>update x set val=val2 where id=1 and val=valold;&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>写入偏差与幻读&lt;/strong>：案例：select count(*) from xx where a=b; 当 count &amp;gt; 2 时，写入一条新的 a=b 的数据；并发写入时，破坏了 count &amp;gt; 2 的约束条件。解决办法：&lt;/p>
&lt;ul>
&lt;li>使用 select for update，显式锁定&lt;/li>
&lt;li>物化冲突。人为地在数据库中引入一组对象，用作锁。比如会议室预定的场景下，可以床架一个时间槽和房间槽的表，写入预定记录之间先使用 select for update 锁定槽位。&lt;/li>
&lt;/ul>
&lt;p>可串行化有多种实现方案：单一线程顺序执行事务（性能低）、两阶段锁定、可串行化快照隔离。&lt;/p>
&lt;p>可串行化的两阶段锁定：读会阻塞写，写会阻塞读；事务提交后释放锁；悲观锁，性能差。&lt;/p>
&lt;p>可串行化的快照隔离方案：乐观锁；事务写入数据库时，必须在索引中查找最近读取的受影响数据的其他事务，如果数据已不是最新的，则中止事务。&lt;/p>
&lt;h2 id="分布式系统的麻烦">
&lt;a href="#%e5%88%86%e5%b8%83%e5%bc%8f%e7%b3%bb%e7%bb%9f%e7%9a%84%e9%ba%bb%e7%83%a6" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
分布式系统的麻烦
&lt;/h2>
&lt;p>分布式系统中容易发生&lt;strong>部分失效&lt;/strong>（以某种不可知的方式被破坏）。部分失效是不确定性的：任何涉及到多个节点和网络的事情，它有可能会工作，有时会出现不可预知的失败。&lt;/p>
&lt;p>不可靠的网络：当发出请求并期待响应，可能在任何节点任何阶段出错。处理这个问题的常用方法是&lt;strong>超时&lt;/strong>。&lt;/p>
&lt;p>不可靠的时钟。NTP 网络时间协议。它允许根据一组服务器报告的时间调整自己的时间。&lt;/p>
&lt;ul>
&lt;li>日历时钟：根据某个日历返回当前的时间，比如 unix 时间戳。日历时钟经常与 NTP 同步，可能导致时间回溯的情况。&lt;/li>
&lt;li>单调时钟：它保证时间总是向前走的，适合测量持续时间（例如时间间隔），NTP 同步时，如果过快，则向前走的频率可以调低 0.05%，如果过慢，则可以调快 0.05%。单调钟可以是系统启动后的纳秒数。&lt;/li>
&lt;li>逻辑时钟，使用递增计数器，而不是石英振荡器。&lt;/li>
&lt;/ul>
&lt;p>真相由多数定义，通过投票以减少对某个特定节点的依赖。&lt;/p>
&lt;p>一个 gc 导致锁失效，但代码继续执行覆盖了后续写入数据的案例：
&lt;img loading="lazy"
src="https://xiang-xx.github.io/./img/gccauseerror.png"
alt="gcerror"
width=1124
height="436" />
使用递增 token；比如使用 zookeeper 作为锁服务，可以使用 txid 或者节点的 cversion 作为令牌，因为它保证单调递增。&lt;/p>
&lt;p>&lt;strong>拜占庭故障&lt;/strong>：有些节点可能因为延迟或其他原因，有意或无意发出错误消息 &amp;ndash; 比如告知没有收到某条写请求。当一个系统中部分节点出现故障、不遵守协议、甚至恶意攻击、扰乱网络时仍能正常工作，称为拜占庭容错。常见系统：飞行控制系统，区块链系统。&lt;/p>
&lt;p>&lt;strong>弱谎言形式&lt;/strong>：假定节点不会故意撒谎，使用防止撒谎的弱形式机制，比如：&lt;/p>
&lt;ul>
&lt;li>网络系统中的校验和，检测可能因为硬件或其他问题导致数据包损坏&lt;/li>
&lt;li>校验用户的输入合法性&lt;/li>
&lt;li>使用加权平均作为从多个分布式系统中同步的值，比如 币价/NTP时间&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>安全性：安全性被违反后，违规行为不能被撤销&lt;/strong> &amp;ndash; 损失已经发生。比如 唯一性和单调序列属于安全性，如果产生了重复值，则系统损失已经发生，这个动作也不会恢复。&lt;strong>活性：活性被破坏后，未来可能恢复&lt;/strong>，比如可用性，如果出现节点故障，暂时不可用，但未来也会是可用的。包括 最终一致性，也属于活性。&lt;/p>
&lt;p>&lt;strong>算法的正确性建立在我们假设的系统之上&lt;/strong>，比如我们假设拜占庭故障节点数量低，所以算法才能成立，我们假定节点存储的数据不丢失，才能保证法定人数算法能够正确。 而现实世界可能会发生各种情况打破假设。 证明算法正确并不意味着它在真实系统中一定正确。&lt;/p>
&lt;h2 id="一致性与共识">
&lt;a href="#%e4%b8%80%e8%87%b4%e6%80%a7%e4%b8%8e%e5%85%b1%e8%af%86" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
一致性与共识
&lt;/h2>
&lt;p>大多数复制的数据库至少提供了&lt;strong>最终一致性&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>线性一致性&lt;/strong>：&lt;strong>数据库提供只有一个数据副本的假象&lt;/strong>，多个客户端在任何时候读取的数据，都能在某个时间点变更后，读到新数据。&lt;/p>
&lt;p>依赖线性一致性的场景：&lt;/p>
&lt;ul>
&lt;li>锁定和领导选举；如果违反线性一致性，则可能出现脑裂&lt;/li>
&lt;li>约束和唯一性保证&lt;/li>
&lt;li>跨信道的时序依赖：比如上传完图片后，发送图片 url 到消息队列，异步任务处理消息获取 url 对应图片并处理，结果图片还未同步到其他节点，访问不到图片，或访问的是旧图片&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>CAP 定理&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>网络分区是一种故障类型，所以它并不是一个选项：它一定会发生&lt;/li>
&lt;li>如果需要线性一致性，则发生副本掉线时，系统需要等待，期间不可用&lt;/li>
&lt;li>如果应用不需要线性一致性，则某个副本断开后，也可以独立处理请求&lt;/li>
&lt;/ul>
&lt;p>顺序保证了线性一致性，线性一致性包含了&lt;strong>因果一致性&lt;/strong>。线性顺序是全序的，表现为系统中好像只有一个副本，而因果关系是偏序的，存在因果的两个事件是有序的，无因果关系的事件无序。线性一致性强于因果一致性。一个系统可以是因果一致的，而避免线性一致性带来的性能损耗。&lt;/p>
&lt;p>为了确定因果顺序，数据库需要知道应用读取了那个版本的数据：&lt;/p>
&lt;ul>
&lt;li>比如写操作需要传入之前读操作得到的数据版本号&lt;/li>
&lt;li>可串行化隔离快照中，数据库检查它读取的版本是否依然是最新的&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>兰伯特时间戳&lt;/strong>：由（计数器，节点ID）组成；计数器更大，时间戳更大；计数器相同，节点ID大的更大。
&lt;img loading="lazy"
src="https://xiang-xx.github.io/./img/lanbotetime.png"
alt="lanbotetime"
width=1122
height="494" />&lt;/p>
&lt;p>&lt;strong>全序广播&lt;/strong>满足两个安全属性：&lt;/p>
&lt;ul>
&lt;li>可靠交付：没有消息丢失，如果消息被传递到一个节点上，它将被传递到所有节点&lt;/li>
&lt;li>全序交付：消息以相同的顺序传递到每个节点&lt;/li>
&lt;/ul>
&lt;p>全序广播的重要表现：顺序在消息送达时被固化，如果后续的消息已经送达，节点就不允许追溯地将之前的消息插入顺序中较早位置。（解决了并发覆盖写导致数据不一致问题）&lt;/p>
&lt;p>使用全序广播实现线性一致性存储。使用仅追加日志的方式实现这种 CAS 操作：&lt;/p>
&lt;ol>
&lt;li>在日志中追加一条消息，并试探性的指明你想要的用户名&lt;/li>
&lt;li>读日志，并等待你刚才追加的消息被读回&lt;/li>
&lt;li>检查是否有任何消息生成目标用户名的所有权，如果第一条是你的消息，则操作成功，你可以提交声称的用户名并向客户端确认。如果第一条消息来自其他用户，则中止操作。&lt;/li>
&lt;/ol>
&lt;p>使用全序广播实现读取线性一致性的方案：&lt;/p>
&lt;ul>
&lt;li>可以先向日志中追加一条消息，直到消息被读回，才执行实际操作 &amp;ndash; 此时说明读之前的消息已全部同步&lt;/li>
&lt;li>查询最新消息的位置（如果允许的话），直到同步到此位置，再进行读取操作&lt;/li>
&lt;li>从同步更新的副本中读取&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>两阶段提交&lt;/strong>使用一个通常不会出现在节点上的新组件：协调者（也叫事务管理器） &amp;ndash; 它可能是客户端上的一个库，或一个进程，或一个单独的服务。协调者向所有参与者（节点）发送 prepare 请求：&lt;/p>
&lt;ul>
&lt;li>如果所有参与者都回答“是”，则协调者在第二阶段发出 commit 请求&lt;/li>
&lt;li>如果任一参与者回答“否”，则协调者在第二阶段发出 abort 请求&lt;/li>
&lt;/ul>
&lt;p>系统承诺：&lt;/p>
&lt;ul>
&lt;li>事务ID全局唯一&lt;/li>
&lt;li>在参与者单节点事务上带上此事务ID&lt;/li>
&lt;li>当应用准备提交，协调者向所有参与者发送 准备 请求，并打上全局事务ID 的标记。如果任一请求失败或超时，则协调者向所有参与者发送针对此事务ID的中止请求&lt;/li>
&lt;li>参与者收到准备请求时，如果回答 是，则参与者需要确保只要请求，就一定能够提交&lt;/li>
&lt;li>当协调者收到所有答复时，会对是否提交事务做出决定；协调者必须把决定写到磁盘的事务日志中，如果随后崩溃恢复，也能够知道自己做出的决定。这被称为提交点&lt;/li>
&lt;li>一旦协调者的决定落盘，提交或放弃请求会发送给所有参与者。如果请求失败或超时，则必须一直重试下去&lt;/li>
&lt;/ul>
&lt;p>协调者失效时，如果刚好有事务执行完第一阶段，未收到第二阶段的参与者节点会一直处于 存疑 状态，直到协调者回复。存疑时会一直持有锁，直到事务提交或中止。&lt;/p>
&lt;p>&lt;strong>共识问题&lt;/strong>通常形式化如下：一个或多个节点可以提议（propose），而共识算法决定（decides）。共识算法必须满足以下性质：&lt;/p>
&lt;ul>
&lt;li>一致同意：没有两个节点的决定不同&lt;/li>
&lt;li>完整性：没有节点决定两次&lt;/li>
&lt;li>有效性：如果一个节点决定了值 v，则 v 由某个节点所倡议&lt;/li>
&lt;li>终止：由所有未崩溃的节点来最终决定值&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>纪元编号与法定人数&lt;/strong>（raft 协议&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>）&lt;/p>
&lt;ul>
&lt;li>协定定义了一个纪元编号，并确保每个时代中，领导者都是唯一的&lt;/li>
&lt;li>纪元编号是递增的，领导者被认为挂掉后，需要重新投票；两个不同时代的领导者之间出现冲突，更高纪元编号的说了算&lt;/li>
&lt;li>必须从 法定人数 的节点中获取选票&lt;/li>
&lt;li>两轮投票：第一次是为了选出领导者；第二次是对选出的领导者进行表决（类似两阶段提交）；这两次投票的法定人群必须相互重叠（即要求法定人数 &amp;gt; n/2）&lt;/li>
&lt;/ul>
&lt;h2 id="批处理">
&lt;a href="#%e6%89%b9%e5%a4%84%e7%90%86" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
批处理
&lt;/h2>
&lt;p>一个 MapReduce 作业和一个 Unix 进程相类比：它接收一个或多个输入，并产生一个或多个输出。MapReduce 在分布式系统上读写文件 &amp;ndash; HDFS Hadoop 分布式文件系统。&lt;/p>
&lt;p>HDFS 在每台机器上运行了一个守护进程，它对外暴露网络服务，允许其他节点访问存储在该机器上的文件。名为 NameNode 的中央服务器会跟踪那个文件块存储在哪个机器上。为了容忍机器和硬盘故障，文件被复制到多台机器上。&lt;/p>
&lt;p>&lt;strong>MapReduce&lt;/strong> 基本工作流程：输入格式解析器处理输入；Mapper 函数提取键值对；输出数据到 Reducer 时会自动按照键值对排序；Reducer 处理每个键的所有值。&lt;/p>
&lt;p>Mapper：Mapper 会在每条输入记录上调用一次，从每条输入记录上提取键值。对于每个输入可以生成任意数量的键值对，包括 None。无状态，每条记录是独立的。&lt;/p>
&lt;p>Reducer：MapReduce 框架拉取由 Map 生成的键值对，收集属于同一个键的所有值，并在这组值上迭代调用 Reducer。Reducer 可以产生输出记录。&lt;/p>
&lt;p>将计算放在数据附近：每个输入文件的大小通常是几百兆，MapReduce 调度器试图在每台存储输入文件副本的机器上运行每个 Mapper。节省了网络复制输入文件的开销。&lt;/p>
&lt;h2 id="流处理">
&lt;a href="#%e6%b5%81%e5%a4%84%e7%90%86" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
流处理
&lt;/h2>
&lt;p>在流处理中，一个事件由生产者产生一次，然后可能由多个消费者处理。相关的事件通常被聚合成一个主题（topic）或流（stream）。&lt;/p>
&lt;p>消息传递系统的方案：&lt;/p>
&lt;ul>
&lt;li>直接从生产者传递给消费者：UDP、无代理的消息库 ZeroMQ nanomsg 等、通过 http 或者 rpc 传递给消费者（webhook）&lt;/li>
&lt;li>消息代理：kafka、redis等&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>消息代理&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>通常 消息传递给消费者后会自动删除（或保存一段时间后删除）&lt;/li>
&lt;li>队列工作集比较小，比如 kafka 默认保存 7 天&lt;/li>
&lt;li>支持按照某种模式匹配主题，订阅其子集&lt;/li>
&lt;li>不支持任何查询，通常只能流式订阅&lt;/li>
&lt;/ul>
&lt;p>多个消费者从同一主题读取消息的模式：负载均衡，每个消息被传递给消费者之一；扇出（fan-out），每个消息被传递给所有消费者。&lt;/p>
&lt;p>确认与重新传递：客户端显式告知消息代理 消息已经处理完毕。&lt;/p>
&lt;p>分区日志：基于日志的消息代理。对日志进行分区，存储在不同的机器上；每个分区内，消息被分配一个单调递增的序列号（或偏移量）。记录消费者消费某个分区消息的进度，称为消费者偏移量。&lt;/p>
&lt;p>当消费者跟不上生产者时：丢弃消息、进行缓冲、施加背压，影响生产者的速度。可以监控消费者落后日志头部的距离，落后太多就发出报警。&lt;/p>
&lt;p>保持多系统数据同步的方式：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>双写&lt;/strong>：比如写入数据库时，同时写入数据库和缓存/ES。但并发写入到每个系统的时间不一致，发生冲突导致系统数据不一致&lt;/li>
&lt;li>&lt;strong>变更数据捕获（CDC）&lt;/strong>：捕获数据库的变更日志，通过消息代理给多个系统消费，同步数据&lt;/li>
&lt;/ul>
&lt;p>系统变更事件是不可变的，所以可以从事件日志派生出当前状态。&lt;/p>
&lt;p>流处理的一些场景：&lt;/p>
&lt;ul>
&lt;li>复合事件处理&lt;/li>
&lt;li>流分析，例如 prometheus（滚动计算、区间对比统计、测试事件速率）&lt;/li>
&lt;li>维护物化视图：缓存，搜索索引，数据仓库&lt;/li>
&lt;li>在流上搜索：先构建搜索查询，再在流数据上跑查询&lt;/li>
&lt;li>消息传递和 rpc&lt;/li>
&lt;/ul>
&lt;p>流分析的时间窗口类型：&lt;/p>
&lt;ul>
&lt;li>滚动窗口：每个事件只能属于一个窗口，比如 一分钟一个窗口&lt;/li>
&lt;li>跳动窗口：固定长度，但允许窗口部分重叠，例如：一个步长为 1 的，长度为 5 的跳动窗口&lt;/li>
&lt;li>滑动窗口：跟跳动相比，没有步长的概念，不断往窗口添加新数据，移除旧数据&lt;/li>
&lt;li>会话窗口：没有固定持续时间，将一个用户出现时间相近的事件联系在一起&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>流流连接&lt;/strong>：在处理流数据时，需要额外的数据库存储流事件，以便另一个事件到达后能够查询到此事件。
&lt;strong>流表连接&lt;/strong>：创建事件时，把数据库副本数据写入到事件里，这样处理事件时不用查询数据库；或者处理事件时查询数据库。&lt;/p>
&lt;p>流处理中的容错手段：微批次和存档点、使用事务原子提交、幂等性、失败后重建状态。&lt;/p>
&lt;h2 id="数据系统的未来">
&lt;a href="#%e6%95%b0%e6%8d%ae%e7%b3%bb%e7%bb%9f%e7%9a%84%e6%9c%aa%e6%9d%a5" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
数据系统的未来
&lt;/h2>
&lt;p>&lt;strong>组合使用衍生数据的工具&lt;/strong>，比如搜索引擎/缓存/分析型数据库。分布式事务性能较低，容错能力差，但提供线性一致性，读己之写；衍生数据通常是异步的，提供最终一致性。&lt;/p>
&lt;p>&lt;strong>组合使用数据库存储技术&lt;/strong>：次级索引、物化视图、复制日志、全文搜索引擎。&lt;/p>
&lt;p>&lt;strong>联合数据库&lt;/strong>：统一读取。为各种各样的底层存储引擎和处理方法提供统一的查询接口；例如 PostgreSQL 的外部数据包装器。&lt;strong>分拆数据库&lt;/strong>：统一写入；变更日志捕获衍生到其他系统。&lt;/p>
&lt;p>将事情做正确：&lt;/p>
&lt;ul>
&lt;li>端到端原则：只有在通信系统两端应用的知识和帮助下，所讨论的功能才能完全正确的实现。比如 tcp 两端需要记录维护序列号；比如幂等操作需要两端都保证唯一标识符。&lt;/li>
&lt;li>强制约束。唯一性约束需要达成共识：最常见的方式是使用单节点作为领导，负责所有决策；全序广播；分区依赖消息日志进行处理。&lt;/li>
&lt;li>及时性与完整性。事务通常提供一致性：一致性实际包含 及时性（线性一致性，读己之写）和完整性。&lt;/li>
&lt;li>信任但验证。不要盲目信任承诺。审计，审查数据完整性。&lt;/li>
&lt;/ul>
&lt;p>做正确的事情：预测性分析可能存在的偏见与歧视，推荐系统的责任问题，反馈循环功能。隐私与追踪需要符合法律法规，防止用户数据滥用，允许用户选择是否同意上传个人数据等。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>《Designing Data-Intensive Applications》Martin Kleppmann. &lt;a href="http://ddia.vonng.com/">中文翻译 冯若航 @Vonng&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Fractal_tree_index">分形树&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>&lt;a href="http://thesecretlivesofdata.com/raft/">raft 协议动画演示&lt;/a>&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>读《计算机程序的构造和解释》</title><link>https://xiang-xx.github.io/posts/read-sicp/</link><pubDate>Sat, 04 Feb 2023 09:31:29 +0800</pubDate><guid>https://xiang-xx.github.io/posts/read-sicp/</guid><description>
&lt;h2 id="前言">
&lt;a href="#%e5%89%8d%e8%a8%80" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
前言
&lt;/h2>
&lt;p>《计算机程序的构造和解释》（Structure and Interpretation of Computer Programs、SICP）&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>，也称 SICP，是麻省理工学院（MIT）计算机科学的入门教材。书中以 Scheme 语言为例（Lisp - List Processing 语言的一种方言），通过大量代码案例，详细介绍了程序如何抽象构造出来，以及程序解释/编译/运行的基本流程。对于日常使用高级语言的工程师来说，阅读此书能够对程序底层运行过程有一定的理解。&lt;/p>
&lt;h2 id="编程语言的抽象">
&lt;a href="#%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80%e7%9a%84%e6%8a%bd%e8%b1%a1" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
编程语言的抽象
&lt;/h2>
&lt;p>编程语言提供一些基础元素，比如基本类型，运算符，关键字等，并使用表达式构建成语句，语句通过一系列的方式构成 复合过程（函数，方法，闭包，lambda 等）。&lt;/p>
&lt;p>一个问题的求解过程通常可以有很多种，比如计算阶乘，可以用简单的递归算法：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">factorial&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">n&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nx">n&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">n&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nf">factorial&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">n&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>此算法的计算过程：先展开，后归约，比如计算 factorial(4)，展开与规约的过程：&lt;/p>
&lt;pre tabindex="0">&lt;code>4 * f(3)
4 * 3 * f(2)
4 * 3 * 2 * f(1)
4 * 3 * 2 * 1
4 * 3 * 2
4 * 6
24
&lt;/code>&lt;/pre>&lt;p>如果使用迭代的方式计算：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">factorial&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">n&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">a&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">n&lt;/span> &lt;span class="p">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">a&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">a&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="nx">n&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">n&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">a&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其计算过程因为没有先展开后规约的过程，所以看上去简洁很多：&lt;/p>
&lt;pre tabindex="0">&lt;code>a = 4 n = 4
a = 12 n = 3
a = 24 n = 2
a = 24 n = 1
&lt;/code>&lt;/pre>&lt;p>书中还提到计算 n 的 k 次方的算法（k &amp;gt; 0）。最直观的解法是递归求 &lt;code>f(n, k) = n * f(n, k-1)&lt;/code>。次方问题可以根据 k 的奇偶进行划分：&lt;/p>
&lt;pre tabindex="0">&lt;code>n 是偶数：f(n, k) = f(n*n, k/2)
n 是奇数：f(n, k) = n * f(n, k-1)
&lt;/code>&lt;/pre>&lt;p>根据上述公式，可以很简单的实现出递归程序，时间复杂度是 O(logk)；在不考虑尾递归优化的情况下，递归使用了额外栈空间，所以空间复杂度也是O(logk)。你可以试着把递归改成迭代形式，以降低空间复杂度。&lt;/p>
&lt;p>Lisp 跟如今的一些高级语言一样，也把函数作为一等公民。函数可以赋值给变量，可以作为参数，可以作为返回值。&lt;/p>
&lt;p>闭包跟普通函数的不同点在于闭包携带的执行环境。执行环境由两部分组成：用于记录环境内变量的表格，和指向外围环境的指针。任何过程在执行时都会有一个执行环境，过程中用到的变量的值，需要从执行环境中查找，如果当前执行环境没有，则向外围环境查找，直到找到，或者外围环境为 nil 为止。&lt;/p>
&lt;p>过程的执行环境是在其创建时决定的，比如一个定义在全局的函数，他的执行环境就是全局共用的 global 环境；一个闭包在函数内创建时，会给它创建一个新的局部环境 &amp;ndash; 表格里记录局部环境的变量，指针指向创建它的函数的环境（可能是 global 或者另外一个局部环境）。&lt;/p>
&lt;h2 id="模块化状态">
&lt;a href="#%e6%a8%a1%e5%9d%97%e5%8c%96%e7%8a%b6%e6%80%81" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
模块化，状态
&lt;/h2>
&lt;p>这是一个带有状态的闭包实现：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-GO" data-lang="GO">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">newWithdraw&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">amount&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">100&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kd">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">a&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">amount&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="nx">a&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nx">amount&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">w&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nf">newWithdraw&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">w&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">w&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>闭包使用局部环境维护了局部状态；同时局部状态隐藏在闭包内部，实现了模块化。但这种方式会导致内部不透明，且构造出的闭包不是同一的，无法互相替代。&lt;/p>
&lt;p>不需要任何赋值操作的设计，成为函数式程序设计，函数式程序设计没有状态修改。与之相反的是命令式程序设计。以求 n 的 k 次方的为例（Ologn 解法），使用递归函数的程序设计简单直观，不容易出错，使用迭代赋值，维护当前状态的命令式函数设计，会导致计算模型更复杂，更容易出错。&lt;/p>
&lt;h2 id="并发的问题">
&lt;a href="#%e5%b9%b6%e5%8f%91%e7%9a%84%e9%97%ae%e9%a2%98" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
并发的问题
&lt;/h2>
&lt;p>lisp 使用互斥锁 mutex 实现串行化组来规避并发问题，使用 test-and-set 判断 mutex 是否可用，test-and-set 使用处理器提供的原子指令。&lt;/p>
&lt;p>死锁案例：两个进程同时修改若干账户的余额，修改每个账户的余额需要先获得该账户的锁，每个进程必须持有全部锁后才能修改完成，并释放锁。这种场景下，可以通过给账户唯一编号，然后按照编号顺序进行锁定，避免死锁发生。&lt;/p>
&lt;p>某些场景无法避免死锁，比如需要先获取到 A账户的锁，根据余额情况再决定锁哪些账户。&lt;/p>
&lt;h2 id="元循环求值器">
&lt;a href="#%e5%85%83%e5%be%aa%e7%8e%af%e6%b1%82%e5%80%bc%e5%99%a8" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
元循环求值器
&lt;/h2>
&lt;p>元循环求值器是指使用自身语言实现的自身代码的求值器。以 lisp 来说，就是用 lisp 写一段程序，这段程序的输入是一段 lisp 程序，并求出这段程序的运行结果。&lt;/p>
&lt;p>求值器的核心函数：&lt;code>eval(exp, env)&lt;/code>, exp 是程序过程，env 是执行环境。eval 返回 exp 在 env 环境下的运行结果。Lisp 语法简单，所以其元循环求值器也很简单：&lt;/p>
&lt;ul>
&lt;li>根据 exp 类型，分别调用子函数求值
&lt;ul>
&lt;li>&lt;code>eval-if(exp, env)&lt;/code>
&lt;ul>
&lt;li>判断 if 谓语真假，然后递归执行 if 模块或 else 模块&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>eval-assign&lt;/code>&lt;/li>
&lt;li>&lt;code>eval-define&lt;/code>&lt;/li>
&lt;li>调用子函数，则 &lt;code>eval (exp, newEnv(vars, env))&lt;/code>，使用新构造的执行环境&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>eval 求值器表较简单，但也很低效。比如对于递归阶乘的求解时，eval 求值器每次递归调用 eval 时都需要重新分析阶乘函数的语法。&lt;/p>
&lt;p>另一种求值方法是把语法分析和执行分离：&lt;code>(analyze (exp)) (env)&lt;/code>。&lt;code>analyze(exp)&lt;/code> 返回语法解析后的闭包，然后把环境 env 应用到闭包里。使用 analyze 对同一个过程只进行一次语法解析。&lt;/p>
&lt;h2 id="惰性求值">
&lt;a href="#%e6%83%b0%e6%80%a7%e6%b1%82%e5%80%bc" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
惰性求值
&lt;/h2>
&lt;p>我们所使用的语言里普遍支持惰性求值。比如在执行 &lt;code>if a &amp;amp;&amp;amp; f() {}&lt;/code> 时，如果 a 是 false，则 f 不再被调用，rust 语言的 Option 类有两个方法，分别是：&lt;/p>
&lt;ul>
&lt;li>&lt;code>unwrap_or(val)&lt;/code> 判断 Options 是否为空，为空，则返回入参 val&lt;/li>
&lt;li>&lt;code>unwrap_or_else(fn)&lt;/code> 判断 Options 是否为空，为空，则返回闭包 fn 的执行结果
其中 &lt;code>wrap_or_else&lt;/code> 使用的也是惰性求值的思想。&lt;/li>
&lt;/ul>
&lt;p>惰性求值的思想还可以用到其他场景：比如我们想要一个无穷的素数流，则可以用生成器函数，实现对下一个素数的惰性求值。&lt;/p>
&lt;h2 id="寄存器机器的设计">
&lt;a href="#%e5%af%84%e5%ad%98%e5%99%a8%e6%9c%ba%e5%99%a8%e7%9a%84%e8%ae%be%e8%ae%a1" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
寄存器机器的设计
&lt;/h2>
&lt;p>寄存器机器包含两个要点：&lt;/p>
&lt;ul>
&lt;li>数据通路：寄存器的操作，比如把寄存器 r0 的值赋值给 r1，或者求两个寄存器的运算结果，并赋值给另外一个寄存器&lt;/li>
&lt;li>控制器：控制指令的执行顺序&lt;/li>
&lt;/ul>
&lt;p>一个包含堆栈的寄存器的基本指令：&lt;/p>
&lt;ul>
&lt;li>设置 label：label 定义程序语句标签，可以使用 branch/goto 指令跳转 label 对应的指令位置&lt;/li>
&lt;li>&lt;code>assign &amp;lt;register-name&amp;gt; &amp;lt;register-name&amp;gt;&lt;/code> 把后面寄存器的值赋值给前面的寄存器内
&lt;ul>
&lt;li>例如：assign r0 r1&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>assign &amp;lt;register-name&amp;gt; &amp;lt;const&amp;gt;&lt;/code> 把常量值赋值给寄存器
&lt;ul>
&lt;li>例如：assign r0 1&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>assign &amp;lt;register-name&amp;gt; &amp;lt;operation&amp;gt;&lt;/code> 把表达式的值赋值给寄存器
&lt;ul>
&lt;li>例如 assign r0 (- r1 r2) 把 r1 - r2 的值赋值给 r0&lt;/li>
&lt;li>assign r0 (&amp;gt; r1 r2) 把 r1 &amp;gt; r2 的结果赋值给 r0 寄存器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>assign &amp;lt;register-name&amp;gt; &amp;lt;label&amp;gt;&lt;/code> 把 label 对应语句指令的指针赋值给寄存器
&lt;ul>
&lt;li>例如：assign r0 gcd 把 gcd 标签语句指针赋值给 r0 寄存器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>test &amp;lt;op&amp;gt; &amp;lt;register-name&amp;gt;|&amp;lt;const&amp;gt; &amp;lt;register-name&amp;gt;|&amp;lt;const&amp;gt;&lt;/code> 用后面两个值，使用操作符 op 进行比较，并把比较结果保存到 flag 寄存器
&lt;ul>
&lt;li>例如：test = r0 1，判断 r0 与常数 1 是否相等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>branch &amp;lt;label&amp;gt;&lt;/code> 判断 flag 的值，如果为 true，则程序跳转到 label 位置&lt;/li>
&lt;li>&lt;code>goto label|reg&lt;/code> 直接跳转到 label 位置，或 register 存储的 label 位置
&lt;ul>
&lt;li>goto gcd&lt;/li>
&lt;li>goto r0&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>save &amp;lt;register-name&amp;gt;&lt;/code> 把寄存器的值存入栈顶
&lt;ul>
&lt;li>save r0&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>restore &amp;lt;register-name&amp;gt;&lt;/code> 从栈顶 pop 出数据，存入寄存器
&lt;ul>
&lt;li>restore r0&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>控制器从 pc 寄存器中读取指令行，并执行对应指令；指令顺序执行，pc 寄存器的值递增；goto，branch 语句控制 pc 寄存器的值，控制程序的跳转；直到没有指令需要执行时，程序结束。&lt;/p>
&lt;p>一段简单的寄存器指令代码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-lisp" data-lang="lisp">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">start&lt;/span> &lt;span class="c1">; 这个 label 不是必须，程序会从第一行执行 &lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nv">assign&lt;/span> &lt;span class="nv">r0&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nv">assign&lt;/span> &lt;span class="nv">r1&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nv">assign&lt;/span> &lt;span class="nv">r2&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">+&lt;/span> &lt;span class="nv">r0&lt;/span> &lt;span class="nv">r1&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">(&lt;/span>&lt;span class="nf">print&lt;/span> &lt;span class="nv">r2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我用 go 语言实现了一个简单的寄存器模拟器，以及两个更复杂的寄存器程序案例 &lt;a href="https://github.com/xiang-xx/go-register-machine">go-register-machine&lt;/a>。&lt;/p>
&lt;h2 id="解释器与编译器">
&lt;a href="#%e8%a7%a3%e9%87%8a%e5%99%a8%e4%b8%8e%e7%bc%96%e8%af%91%e5%99%a8" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
解释器与编译器
&lt;/h2>
&lt;p>为了能够在高级语言和寄存器语言的鸿沟上架起一道桥梁，通常存在着两种策略：&lt;/p>
&lt;ul>
&lt;li>解释器模式&lt;/li>
&lt;li>编译模式&lt;/li>
&lt;/ul>
&lt;p>解释器模式就是使用上述寄存器语言实现一个解释器，它能循环读取高级语言，并实时运行。很多解释型语言都有命令行模式，比如 nodejs，python，php 等。&lt;/p>
&lt;p>编译器模式：可以使用任何语言实现编译器，它读取高级语言，并把它的过程翻译成寄存器语言。&lt;/p>
&lt;p>与解释方式相比，编译方式能够大大提高程序的执行效率。另一方面，解释器则为程序的开发和排查错误提供了一个更强大的环境，因为被执行的源代码在运行期间是可用的，可以取检查和修改。&lt;/p>
&lt;h2 id="总结">
&lt;a href="#%e6%80%bb%e7%bb%93" class="anchor">
&lt;svg class="icon" aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16">
&lt;path fill-rule="evenodd"
d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z">
&lt;/path>
&lt;/svg>
&lt;/a>
总结
&lt;/h2>
&lt;p>以上只是我对书中的一些关键概念和案例做的摘要。书中还对流数据处理，非确定型计算等做了详细介绍，因为与我常用技术关联不大，所以这里没有涉及。书中对于元循环求值器，寄存器机器设计，解释器，编译器都有完整的 lisp 代码讲解，阅读这些源代码能够提升对程序执行原理的认识。&lt;/p>
&lt;p>本书毕竟是入门教材，书中所述的垃圾回收/寄存器程序/解释器/编译器等实现方式都比较简单，以达到浅显易懂的目的。我们日常使用的高级语言，其底层设计会更加复杂。阅读此书能帮助我们打开这扇门，里面更广阔的内容还需要不断探索。&lt;/p>
&lt;p>你可以在&lt;a href="https://awesome-programming-books.github.io/computer-system/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89.pdf">这里下载原书的 pdf 版&lt;/a>。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>《计算机程序的构造和解释》Structure and Interpretation of Computer Programs(SICP) 作者：Harold Abels，Gerald Jay Sussman， Julie Sussman&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item></channel></rss>
---
date: 2023-02-04T09:31:29+08:00
title: "读《计算机程序的构造和解释》"
description: "《计算机程序的构造和解释》书籍中一些关键概念的摘要"
tags: ["阅读"]
series: []
---

## 前言

《计算机程序的构造和解释》（Structure and Interpretation of Computer Programs、SICP）[^1]，也称 SICP，是麻省理工学院（MIT）计算机科学的入门教材。书中以 Scheme 语言为例（Lisp - List Processing 语言的一种方言），通过大量代码案例，详细介绍了程序如何抽象构造出来，以及程序解释/编译/运行的基本流程。对于日常使用高级语言的工程师来说，阅读此书能够对程序底层运行过程有一定的理解。


## 编程语言的抽象

编程语言提供一些基础元素，比如基本类型，运算符，关键字等，并使用表达式构建成语句，语句通过一系列的方式构成 复合过程（函数，方法，闭包，lambda 等）。

一个问题的求解过程通常可以有很多种，比如计算阶乘，可以用简单的递归算法：
```go
func factorial(n int) int {
    if n == 1 {       
        return 1    
    }
    return n * factorial(n-1)
}
```
此算法的计算过程：先展开，后归约，比如计算 factorial(4)，展开与规约的过程：
```
4 * f(3)
4 * 3 * f(2)
4 * 3 * 2 * f(1)
4 * 3 * 2 * 1
4 * 3 * 2
4 * 6
24
```
如果使用迭代的方式计算：
```go
func factorial(n int) int {
    a := 1    
    for n > 0 {        
        a = a * n        
        n -= 1    
    }    
    return a
}
```
其计算过程因为没有先展开后规约的过程，所以看上去简洁很多：
```
a = 4 n = 4
a = 12 n = 3
a = 24 n = 2
a = 24 n = 1
```
书中还提到计算 n 的 k 次方的算法（k > 0）。最直观的解法是递归求 `f(n, k) = n * f(n, k-1)`。次方问题可以根据 k 的奇偶进行划分：
```
n 是偶数：f(n, k) = f(n*n, k/2)
n 是奇数：f(n, k) = n * f(n, k-1)
```
根据上述公式，可以很简单的实现出递归程序，时间复杂度是 O(logk)；在不考虑尾递归优化的情况下，递归使用了额外栈空间，所以空间复杂度也是O(logk)。你可以试着把递归改成迭代形式，以降低空间复杂度。

Lisp 跟如今的一些高级语言一样，也把函数作为一等公民。函数可以赋值给变量，可以作为参数，可以作为返回值。

闭包跟普通函数的不同点在于闭包携带的执行环境。执行环境由两部分组成：用于记录环境内变量的表格，和指向外围环境的指针。任何过程在执行时都会有一个执行环境，过程中用到的变量的值，需要从执行环境中查找，如果当前执行环境没有，则向外围环境查找，直到找到，或者外围环境为 nil 为止。

过程的执行环境是在其创建时决定的，比如一个定义在全局的函数，他的执行环境就是全局共用的 global 环境；一个闭包在函数内创建时，会给它创建一个新的局部环境 -- 表格里记录局部环境的变量，指针指向创建它的函数的环境（可能是 global 或者另外一个局部环境）。

## 模块化，状态

这是一个带有状态的闭包实现：
```GO
func newWithdraw() func(int) int {    
    amount := 100    
    return func(a int) int {        
        amount -= a        
        return amount    
    }
}
w := newWithdraw()
println(w(10))
println(w(20))
```
闭包使用局部环境维护了局部状态；同时局部状态隐藏在闭包内部，实现了模块化。但这种方式会导致内部不透明，且构造出的闭包不是同一的，无法互相替代。

不需要任何赋值操作的设计，成为函数式程序设计，函数式程序设计没有状态修改。与之相反的是命令式程序设计。以求 n 的 k 次方的为例（Ologn 解法），使用递归函数的程序设计简单直观，不容易出错，使用迭代赋值，维护当前状态的命令式函数设计，会导致计算模型更复杂，更容易出错。

## 并发的问题

lisp 使用互斥锁 mutex 实现串行化组来规避并发问题，使用 test-and-set 判断 mutex 是否可用，test-and-set 使用处理器提供的原子指令。

死锁案例：两个进程同时修改若干账户的余额，修改每个账户的余额需要先获得该账户的锁，每个进程必须持有全部锁后才能修改完成，并释放锁。这种场景下，可以通过给账户唯一编号，然后按照编号顺序进行锁定，避免死锁发生。

某些场景无法避免死锁，比如需要先获取到 A账户的锁，根据余额情况再决定锁哪些账户。

## 元循环求值器

元循环求值器是指使用自身语言实现的自身代码的求值器。以 lisp 来说，就是用 lisp 写一段程序，这段程序的输入是一段 lisp 程序，并求出这段程序的运行结果。

求值器的核心函数：`eval(exp, env)`, exp 是程序过程，env 是执行环境。eval 返回 exp 在 env 环境下的运行结果。Lisp 语法简单，所以其元循环求值器也很简单：
- 根据 exp 类型，分别调用子函数求值
    - `eval-if(exp, env)`
      - 判断 if 谓语真假，然后递归执行 if 模块或 else 模块
    - `eval-assign`
    - `eval-define`
    - 调用子函数，则 `eval (exp, newEnv(vars, env))`，使用新构造的执行环境
    - ...

eval 求值器表较简单，但也很低效。比如对于递归阶乘的求解时，eval 求值器每次递归调用 eval 时都需要重新分析阶乘函数的语法。

另一种求值方法是把语法分析和执行分离：`(analyze (exp)) (env)`。`analyze(exp)` 返回语法解析后的闭包，然后把环境 env 应用到闭包里。使用 analyze 对同一个过程只进行一次语法解析。

## 惰性求值

我们所使用的语言里普遍支持惰性求值。比如在执行 `if a && f() {}` 时，如果 a 是 false，则 f 不再被调用，rust 语言的 Option 类有两个方法，分别是： 
- `unwrap_or(val)` 判断 Options 是否为空，为空，则返回入参 val
- `unwrap_or_else(fn)` 判断 Options 是否为空，为空，则返回闭包 fn 的执行结果
其中 `wrap_or_else` 使用的也是惰性求值的思想。

惰性求值的思想还可以用到其他场景：比如我们想要一个无穷的素数流，则可以用生成器函数，实现对下一个素数的惰性求值。

## 寄存器机器的设计

寄存器机器包含两个要点：
- 数据通路：寄存器的操作，比如把寄存器 r0 的值赋值给 r1，或者求两个寄存器的运算结果，并赋值给另外一个寄存器
- 控制器：控制指令的执行顺序

一个包含堆栈的寄存器的基本指令：
- 设置 label：label 定义程序语句标签，可以使用 branch/goto 指令跳转 label 对应的指令位置
- `assign <register-name> <register-name>` 把后面寄存器的值赋值给前面的寄存器内
  - 例如：assign r0 r1
- `assign <register-name> <const>` 把常量值赋值给寄存器
  - 例如：assign r0 1
- `assign <register-name> <operation>` 把表达式的值赋值给寄存器
  - 例如 assign r0 (- r1 r2) 把 r1 - r2 的值赋值给 r0
  - assign r0 (> r1 r2) 把 r1 > r2 的结果赋值给 r0 寄存器
- `assign <register-name> <label>` 把 label 对应语句指令的指针赋值给寄存器
  - 例如：assign r0 gcd 把 gcd 标签语句指针赋值给 r0 寄存器
- `test <op> <register-name>|<const> <register-name>|<const>` 用后面两个值，使用操作符 op 进行比较，并把比较结果保存到 flag 寄存器
  - 例如：test = r0 1，判断 r0 与常数 1 是否相等
- `branch <label>` 判断 flag 的值，如果为 true，则程序跳转到 label 位置
- `goto label|reg` 直接跳转到 label 位置，或 register 存储的 label 位置
  - goto gcd
  - goto r0
- `save <register-name>` 把寄存器的值存入栈顶
  - save r0
- `restore <register-name>` 从栈顶 pop 出数据，存入寄存器
  - restore r0

控制器从 pc 寄存器中读取指令行，并执行对应指令；指令顺序执行，pc 寄存器的值递增；goto，branch 语句控制 pc 寄存器的值，控制程序的跳转；直到没有指令需要执行时，程序结束。

一段简单的寄存器指令代码：
```lisp
start  ; 这个 label 不是必须，程序会从第一行执行  
  (assign r0 1)  
  (assign r1 2)  
  (assign r2 (+ r0 r1))  
  (print r2)
```
我用 go 语言实现了一个简单的寄存器模拟器，以及两个更复杂的寄存器程序案例 [go-register-machine](https://github.com/xiang-xx/go-register-machine)。

## 解释器与编译器

为了能够在高级语言和寄存器语言的鸿沟上架起一道桥梁，通常存在着两种策略：
- 解释器模式
- 编译模式

解释器模式就是使用上述寄存器语言实现一个解释器，它能循环读取高级语言，并实时运行。很多解释型语言都有命令行模式，比如 nodejs，python，php 等。

编译器模式：可以使用任何语言实现编译器，它读取高级语言，并把它的过程翻译成寄存器语言。

与解释方式相比，编译方式能够大大提高程序的执行效率。另一方面，解释器则为程序的开发和排查错误提供了一个更强大的环境，因为被执行的源代码在运行期间是可用的，可以取检查和修改。

## 总结

以上只是我对书中的一些关键概念和案例做的摘要。书中还对流数据处理，非确定型计算等做了详细介绍，因为与我常用技术关联不大，所以这里没有涉及。书中对于元循环求值器，寄存器机器设计，解释器，编译器都有完整的 lisp 代码讲解，阅读这些源代码能够提升对程序执行原理的认识。

本书毕竟是入门教材，书中所述的垃圾回收/寄存器程序/解释器/编译器等实现方式都比较简单，以达到浅显易懂的目的。我们日常使用的高级语言，其底层设计会更加复杂。阅读此书能帮助我们打开这扇门，里面更广阔的内容还需要不断探索。

你可以在[这里下载原书的 pdf 版](https://awesome-programming-books.github.io/computer-system/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89.pdf)。

[^1]: 《计算机程序的构造和解释》Structure and Interpretation of Computer Programs(SICP) 作者：Harold Abels，Gerald Jay Sussman， Julie Sussman